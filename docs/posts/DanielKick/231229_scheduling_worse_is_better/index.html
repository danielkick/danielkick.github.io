<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Daniel Kick">
<meta name="dcterms.date" content="2023-12-19">

<title>Worse is better case study 1</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<script src="../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../posts/DanielKick/index.html"> 
<span class="menu-text">Posts</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="https://github.com/danielkick/Resume/blob/main/Resume.pdf"> 
<span class="menu-text">Resume</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://github.com/danielkick/Resume/blob/main/Curriculum-Vitae.pdf"> 
<span class="menu-text">CV</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/danielkick"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/daniel-kick-5a449b9a/"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Worse is better case study 1</h1>
            <p class="subtitle lead">Safety First with Scheduling</p>
                                <div class="quarto-categories">
                <div class="quarto-category">beginner</div>
                <div class="quarto-category">code</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Daniel Kick </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">December 19, 2023</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<!-- https://commons.wikimedia.org/wiki/File:Ariopelta_capensis.png -->
<p><a href="https://slurm.schedmd.com/documentation.html">Slurm</a><a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> is a tool commonly available on computing clusters for scheduling job. For a while I’ve wanted a local instalition of it so I can queue computational experiments to run while I’m sleeping or gone. Trouble is, it’s never been a high enough priority to devote much time to getting it set up (or convince a sysadmin to help me set it up). Every few months I’ll work through a tutorial until I find I’ve exhausted the time set aside for the task without a working installation. After the most recent cycle of this I resolved to build an imperfect solution instead.</p>
<section id="thinking-throught-the-system-requirements" class="level2">
<h2 class="anchored" data-anchor-id="thinking-throught-the-system-requirements">Thinking throught the system requirements</h2>
<p>Let’s start with what I want my solution to do:</p>
<ol type="1">
<li><p>Run jupyter notebooks</p></li>
<li><p>Maintain a queue of jobs to run</p></li>
<li><p>Make sure that resources (here the GPU’s memory) are free for the next job and run jobs as other jobs finish<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p></li>
<li><p>Control the system (add jobs to be run and such)</p></li>
</ol>
<p>Jupyter notebooks can be run from the command line in a virtual environment (e.g.<code>conda run -n gpu_env jupyter execute notebook0.ipynb</code>).</p>
<p>A queue could be as simple as a list of notebooks to be run (maintained in a list or a text file) so this requirement is easy to satisfy. Without the In the simplest conception, the jobs could listed (separated by a <code>;</code>) and run from the command line and each would run in turn. This would not allow for modifying the queue however.</p>
<p>Freeing up resources is and starting new jobs is more challenging. Ideally when the notebook finishes running it should release the resources but what if there’s an error or bug the process release them? In a notebook we could include <code>os._exit(00)</code> in the last cell to kill the process but if the notebook runs correctly this shouldn’t be an issue. As a fail safe I could keep an eye on what new programs are using the GPU and if they don’t release memory stop them with <code>kill -9 $PID</code>. Not a <em>pretty</em> solution (and if I start another process that uses the GPU, it could get killed) but it will work.</p>
<p>Lastly is a way to control the system. There needs to be a way to modify it’s state even if it’s running in the background. A simple way to do this would be to specify commands files in a specific location and naming convention.</p>
</section>
<section id="implementation" class="level2">
<h2 class="anchored" data-anchor-id="implementation">Implementation</h2>
<p>I’m using <code>python</code> for this tool since I find it’s more readable than <code>bash</code>. The notebooks I want to schedule are in a single directory so I’ll add a file, <code>SchedulerControlCenter.py</code>, there and a folder for the control files I’ll use to modify the scheduler’s state.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode numberSource bash number-lines code-with-copy"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1"></a><span class="bu">.</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="ex">├──</span> notebook0.ipynb</span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="ex">├──</span> notebook1.ipynb</span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="ex">├──</span> ...</span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="ex">├──</span> SchedulerControlCenter.py</span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="ex">└──</span> SchedulerFiles</span>
<span id="cb1-7"><a href="#cb1-7"></a>    <span class="ex">└──</span> ctrl0.json</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<section id="control" class="level3">
<h3 class="anchored" data-anchor-id="control">Control</h3>
<p>Starting with the control files, I’d like to be able to add, remove, and move jobs in the queue, prevent a process from being closed (if I’m using the GPU while this is running), print information on the system’s state, and provide some notes to the user (in case I forget details later).</p>
<p>Here’s a dictionary with keys corresponding to each of these cases.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1"></a>data <span class="op">=</span> {</span>
<span id="cb2-2"><a href="#cb2-2"></a>    <span class="st">'info'</span>                :[],                  <span class="co"># Print this message</span></span>
<span id="cb2-3"><a href="#cb2-3"></a>    <span class="st">'nvidia_base_pids_add'</span>:[<span class="st">'40082'</span>],           <span class="co"># Prevent a specific PID from being autoclosed. </span></span>
<span id="cb2-4"><a href="#cb2-4"></a>    <span class="st">'nvidia_base_pids_del'</span>:[<span class="st">'40082'</span>],           <span class="co"># Allow a specific PID to be autoclosed.</span></span>
<span id="cb2-5"><a href="#cb2-5"></a>    <span class="st">'ipynb_names_read'</span>    :[],                  <span class="co"># Print currently queued notebooks.</span></span>
<span id="cb2-6"><a href="#cb2-6"></a>    <span class="st">'ipynb_names_add'</span>     :[<span class="st">'notebook0.ipynb'</span>], <span class="co"># Add a notebook (to the end) of the queue</span></span>
<span id="cb2-7"><a href="#cb2-7"></a>    <span class="st">'ipynb_names_next'</span>    :[<span class="st">'notebook0.ipynb'</span>], <span class="co"># Add a notebook to the beginning of the queue (does not need to be in the queue)</span></span>
<span id="cb2-8"><a href="#cb2-8"></a>    <span class="st">'ipynb_names_del'</span>     :[<span class="st">'notebook0.ipynb'</span>], <span class="co"># Remove a notebook from the queue</span></span>
<span id="cb2-9"><a href="#cb2-9"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>To make things easy I’ll create a function to write a dictionary as json and autoname the file (so I don’t overwrite unprocessed commands).</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1"></a><span class="im">import</span> json</span>
<span id="cb3-2"><a href="#cb3-2"></a></span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="kw">def</span> write_ctrl_json(data: <span class="bu">dict</span>):</span>
<span id="cb3-4"><a href="#cb3-4"></a>    ctrl_files <span class="op">=</span> [e <span class="cf">for</span> e <span class="kw">in</span> os.listdir(<span class="st">'./SchedulerFiles/'</span>) <span class="cf">if</span> (re.match(<span class="st">'ctrl.json'</span>, e) <span class="kw">or</span> re.match(<span class="st">'ctrl\d+.json'</span>, e))]</span>
<span id="cb3-5"><a href="#cb3-5"></a>    <span class="co"># find the next number to write to. In case 'ctrl.json' and 'ctrl0.json' exist, I'll write to 1</span></span>
<span id="cb3-6"><a href="#cb3-6"></a>    max_num <span class="op">=</span> [e.replace(<span class="st">'ctrl'</span>, <span class="st">''</span>).replace(<span class="st">'.json'</span>, <span class="st">''</span>) <span class="cf">for</span> e <span class="kw">in</span>  ctrl_files]</span>
<span id="cb3-7"><a href="#cb3-7"></a>    max_num <span class="op">=</span> [<span class="bu">int</span>(e) <span class="cf">for</span> e <span class="kw">in</span> max_num <span class="cf">if</span> e <span class="op">!=</span> <span class="st">''</span>]</span>
<span id="cb3-8"><a href="#cb3-8"></a>    <span class="cf">if</span> max_num <span class="op">==</span> []: max_num <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb3-9"><a href="#cb3-9"></a>    <span class="cf">else</span>: max_num <span class="op">=</span> <span class="bu">max</span>(max_num)</span>
<span id="cb3-10"><a href="#cb3-10"></a></span>
<span id="cb3-11"><a href="#cb3-11"></a>    <span class="cf">with</span> <span class="bu">open</span>(<span class="ss">f'./SchedulerFiles/ctrl</span><span class="sc">{</span>max_num<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">.json'</span>, <span class="st">'w'</span>, encoding<span class="op">=</span><span class="st">'utf-8'</span>) <span class="im">as</span> f:</span>
<span id="cb3-12"><a href="#cb3-12"></a>        json.dump(data, f, ensure_ascii<span class="op">=</span><span class="va">False</span>, indent<span class="op">=</span><span class="dv">4</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="the-scheduler" class="level3">
<h3 class="anchored" data-anchor-id="the-scheduler">The Scheduler</h3>
<section id="setup" class="level4">
<h4 class="anchored" data-anchor-id="setup">Setup</h4>
<p>In practice I’ll begin by writing these control files then start the scheduler. I’ll need to parse the instructions, run the first job, check for new instructions, then run the next job and then repeat this until all jobs are complete. In between jobs, I’ll compare the processes running on the GPU and if any are not supposed to be there, stop them.</p>
<p>I’ll keep track of the original state (<code>nvidia_base_pids</code>) of the GPU using a list of the PIDs that were running on it and current state as a dictionary (<code>nvidia_state</code>) which makes it easy to keep additional information for future use (e.g.&nbsp;how much memory is being used). The queue itself (<code>ipynb_names</code>) can be a simple list of the files to be run. These will need to be populated either from the GPU’s current state (with <code>_init_nvidia()</code>) or from the control files (with <code>_parse_ctrl_jsons()</code>). After that, the scheduler can begin working through the queued notebooks, controlled by the <code>main()</code> method.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1"></a><span class="im">import</span> os, subprocess, re, json</span>
<span id="cb4-2"><a href="#cb4-2"></a></span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="kw">class</span> Scheduler():</span>
<span id="cb4-4"><a href="#cb4-4"></a>  <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb4-5"><a href="#cb4-5"></a>        <span class="va">self</span>.background_mode <span class="op">=</span> background_mode</span>
<span id="cb4-6"><a href="#cb4-6"></a>        <span class="va">self</span>.nvidia_base_pids <span class="op">=</span> []</span>
<span id="cb4-7"><a href="#cb4-7"></a>        <span class="va">self</span>.nvidia_state <span class="op">=</span> {}</span>
<span id="cb4-8"><a href="#cb4-8"></a>        <span class="va">self</span>._init_nvidia()</span>
<span id="cb4-9"><a href="#cb4-9"></a>        <span class="va">self</span>.ipynb_names <span class="op">=</span> []</span>
<span id="cb4-10"><a href="#cb4-10"></a>        <span class="va">self</span>._parse_ctrl_jsons()</span>
<span id="cb4-11"><a href="#cb4-11"></a>        <span class="va">self</span>.main()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The GPU’s initial state needs to be recorded which I’ll do by reading all the processes running on it, and saving these PIDs.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1"></a>    <span class="kw">def</span> _init_nvidia(<span class="va">self</span>):</span>
<span id="cb5-2"><a href="#cb5-2"></a>        <span class="va">self</span>._read_nvidia()</span>
<span id="cb5-3"><a href="#cb5-3"></a>        <span class="va">self</span>.nvidia_base_pids <span class="op">=</span> <span class="bu">list</span>(<span class="va">self</span>.nvidia_state.keys())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Finding these processes takes a little doing. From the command line <code>nvidia-smi</code> produces a nicely formatted text table with this information. I’ve used <code>subprocess</code> to capture this information, and then I’ve parsed the table to get the relevant rows and put the information from each into a dictionary (in the list <code>running_processes</code>). Then each dictionary is saved in the <code>self.nvidia_state</code> under it’s process name.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1"></a>    <span class="kw">def</span> _read_nvidia(<span class="va">self</span>):    </span>
<span id="cb6-2"><a href="#cb6-2"></a>        x <span class="op">=</span> subprocess.run(<span class="st">"nvidia-smi"</span>, shell<span class="op">=</span><span class="va">True</span>, check<span class="op">=</span><span class="va">True</span>,  capture_output<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb6-3"><a href="#cb6-3"></a></span>
<span id="cb6-4"><a href="#cb6-4"></a>        x <span class="op">=</span> <span class="bu">str</span>(x).split(<span class="st">'</span><span class="ch">\\</span><span class="st">n'</span>)</span>
<span id="cb6-5"><a href="#cb6-5"></a></span>
<span id="cb6-6"><a href="#cb6-6"></a>        table_blocks <span class="op">=</span> [i <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(x)) <span class="cf">if</span> re.match(<span class="st">'.+===+.+'</span>, x[i])]</span>
<span id="cb6-7"><a href="#cb6-7"></a>        table_breaks <span class="op">=</span> [i <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(x)) <span class="cf">if</span> re.match(<span class="st">'.+---+.+'</span>, x[i])]</span>
<span id="cb6-8"><a href="#cb6-8"></a>        process_row  <span class="op">=</span> [i <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(x)) <span class="cf">if</span> re.match(<span class="st">'.+ Processes: .+'</span>, x[i])]</span>
<span id="cb6-9"><a href="#cb6-9"></a>        start_line <span class="op">=</span> [i <span class="cf">for</span> i <span class="kw">in</span> table_blocks <span class="cf">if</span> i <span class="op">&gt;</span> process_row[<span class="dv">0</span>] ][<span class="dv">0</span>]</span>
<span id="cb6-10"><a href="#cb6-10"></a>        end_line   <span class="op">=</span> [i <span class="cf">for</span> i <span class="kw">in</span> table_breaks <span class="cf">if</span> i <span class="op">&gt;</span> process_row[<span class="dv">0</span>] ][<span class="dv">0</span>]</span>
<span id="cb6-11"><a href="#cb6-11"></a></span>
<span id="cb6-12"><a href="#cb6-12"></a>        running_processes <span class="op">=</span> [x[i] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(start_line<span class="op">+</span><span class="dv">1</span>, end_line)]</span>
<span id="cb6-13"><a href="#cb6-13"></a>        running_processes <span class="op">=</span> [<span class="bu">dict</span>(<span class="bu">zip</span>(</span>
<span id="cb6-14"><a href="#cb6-14"></a>            [<span class="st">'GPU'</span>, <span class="st">'GI'</span>, <span class="st">'CI'</span>, <span class="st">'PID'</span>, <span class="st">'Type'</span>, <span class="st">'ProcessName'</span>, <span class="st">'GPUMem'</span>],</span>
<span id="cb6-15"><a href="#cb6-15"></a>            [e <span class="cf">for</span> e <span class="kw">in</span> line.strip(<span class="st">'|'</span>).split(<span class="st">' '</span>) <span class="cf">if</span> e <span class="op">!=</span> <span class="st">''</span>])) <span class="cf">for</span> line <span class="kw">in</span> running_processes]</span>
<span id="cb6-16"><a href="#cb6-16"></a></span>
<span id="cb6-17"><a href="#cb6-17"></a>        <span class="cf">for</span> e <span class="kw">in</span> running_processes:</span>
<span id="cb6-18"><a href="#cb6-18"></a>            <span class="va">self</span>.nvidia_state[e[<span class="st">'PID'</span>]] <span class="op">=</span> e</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="reading-controls" class="level4">
<h4 class="anchored" data-anchor-id="reading-controls">Reading controls</h4>
<p>Now it needs to read the control files. I’ll identify all the json files in <code>./SchedulerFiles/</code> that begin with ‘ctrl’ then run each in turn<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>. After a file is read the method will check if any of the keys are ‘info’ and return a help message<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> if so. Then it will go through each key in order and modify <code>self.nvidia_base_pids</code> or <code>self.ipynb_names</code> accordingly. After a file is processed, it will delete it so that the system doesn’t get trapped in a loop – adding the same notebooks to the queue over and over.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1"></a>    <span class="kw">def</span> _parse_ctrl_jsons(<span class="va">self</span>):</span>
<span id="cb8-2"><a href="#cb8-2"></a>        ctrl_files <span class="op">=</span> [e <span class="cf">for</span> e <span class="kw">in</span> os.listdir(<span class="st">'./SchedulerFiles/'</span>) <span class="cf">if</span> (re.match(<span class="st">'ctrl.json'</span>, e) <span class="kw">or</span> re.match(<span class="st">'ctrl\d+.json'</span>, e))]</span>
<span id="cb8-3"><a href="#cb8-3"></a>        <span class="cf">if</span> <span class="bu">len</span>(ctrl_files) <span class="op">&gt;=</span> <span class="dv">1</span>:</span>
<span id="cb8-4"><a href="#cb8-4"></a>            <span class="cf">for</span> ctrl_file <span class="kw">in</span> ctrl_files:            </span>
<span id="cb8-5"><a href="#cb8-5"></a>                <span class="cf">with</span> <span class="bu">open</span>(<span class="st">'./SchedulerFiles/'</span><span class="op">+</span>ctrl_file, <span class="st">'r'</span>) <span class="im">as</span> f:</span>
<span id="cb8-6"><a href="#cb8-6"></a>                    data <span class="op">=</span> json.load(f)</span>
<span id="cb8-7"><a href="#cb8-7"></a></span>
<span id="cb8-8"><a href="#cb8-8"></a>                keys <span class="op">=</span> <span class="bu">tuple</span>(data.keys())</span>
<span id="cb8-9"><a href="#cb8-9"></a></span>
<span id="cb8-10"><a href="#cb8-10"></a>                <span class="cf">if</span> <span class="st">'info'</span> <span class="kw">in</span> keys:</span>
<span id="cb8-11"><a href="#cb8-11"></a>                    <span class="bu">print</span>(<span class="st">"""Text ommited for space"""</span>)</span>
<span id="cb8-12"><a href="#cb8-12"></a>                <span class="cf">for</span> key <span class="kw">in</span> keys:</span>
<span id="cb8-13"><a href="#cb8-13"></a>                    <span class="cf">if</span> <span class="st">'nvidia_base_pids_add'</span> <span class="op">==</span> key:</span>
<span id="cb8-14"><a href="#cb8-14"></a>                        <span class="va">self</span>.nvidia_base_pids <span class="op">+=</span> data[key]</span>
<span id="cb8-15"><a href="#cb8-15"></a>                    <span class="cf">if</span> <span class="st">'nvidia_base_pids_del'</span> <span class="op">==</span> key:</span>
<span id="cb8-16"><a href="#cb8-16"></a>                        <span class="va">self</span>.nvidia_base_pids <span class="op">=</span> [e <span class="cf">for</span> e <span class="kw">in</span> <span class="va">self</span>.nvidia_base_pids <span class="cf">if</span> e <span class="kw">not</span> <span class="kw">in</span> data[key]]</span>
<span id="cb8-17"><a href="#cb8-17"></a>                    <span class="cf">if</span> <span class="st">'ipynb_names_read'</span> <span class="op">==</span> key:</span>
<span id="cb8-18"><a href="#cb8-18"></a>                        <span class="bu">print</span>(<span class="va">self</span>.ipynb_names)</span>
<span id="cb8-19"><a href="#cb8-19"></a>                    <span class="cf">if</span> <span class="st">'ipynb_names_add'</span> <span class="op">==</span> key:</span>
<span id="cb8-20"><a href="#cb8-20"></a>                        <span class="va">self</span>.ipynb_names <span class="op">+=</span> data[key]</span>
<span id="cb8-21"><a href="#cb8-21"></a>                    <span class="cf">if</span> <span class="st">'ipynb_names_next'</span> <span class="op">==</span> key:</span>
<span id="cb8-22"><a href="#cb8-22"></a>                        <span class="co"># technically this could be used to add files and set them to first</span></span>
<span id="cb8-23"><a href="#cb8-23"></a>                        <span class="va">self</span>.ipynb_names <span class="op">=</span> data[key]<span class="op">+</span>[e <span class="cf">for</span> e <span class="kw">in</span> <span class="va">self</span>.ipynb_names  <span class="cf">if</span> e <span class="op">!=</span> data[key]]</span>
<span id="cb8-24"><a href="#cb8-24"></a>                    <span class="cf">if</span> <span class="st">'ipynb_names_del'</span> <span class="op">==</span> key:</span>
<span id="cb8-25"><a href="#cb8-25"></a>                        <span class="va">self</span>.ipynb_names <span class="op">=</span> [e <span class="cf">for</span> e <span class="kw">in</span> <span class="va">self</span>.ipynb_names <span class="cf">if</span> e <span class="op">!=</span> data[key]]</span>
<span id="cb8-26"><a href="#cb8-26"></a>                </span>
<span id="cb8-27"><a href="#cb8-27"></a>                <span class="co"># remove the file</span></span>
<span id="cb8-28"><a href="#cb8-28"></a>                os.unlink(<span class="st">'./SchedulerFiles/'</span><span class="op">+</span>ctrl_file)            </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="running-the-next-job" class="level4">
<h4 class="anchored" data-anchor-id="running-the-next-job">Running the next job</h4>
<p>Now there’s a way to add jobs to the queue there needs to be a method to run them. This method will check if there’s a file to be run, if it exists, and if so use <code>subprocess</code> to run it in the appropriate <code>conda</code> virtual environment.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1"></a>    <span class="kw">def</span> _advance_queue(<span class="va">self</span>):</span>
<span id="cb9-2"><a href="#cb9-2"></a>        <span class="cf">if</span> <span class="bu">len</span>(<span class="va">self</span>.ipynb_names) <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb9-3"><a href="#cb9-3"></a>            <span class="cf">pass</span></span>
<span id="cb9-4"><a href="#cb9-4"></a>        <span class="cf">else</span>:</span>
<span id="cb9-5"><a href="#cb9-5"></a>            ipynb_name <span class="op">=</span> <span class="va">self</span>.ipynb_names.pop(<span class="dv">0</span>)</span>
<span id="cb9-6"><a href="#cb9-6"></a>            <span class="cf">if</span> os.path.exists(ipynb_name) <span class="op">==</span> <span class="va">False</span>:</span>
<span id="cb9-7"><a href="#cb9-7"></a>                <span class="cf">pass</span></span>
<span id="cb9-8"><a href="#cb9-8"></a>            <span class="cf">else</span>:</span>
<span id="cb9-9"><a href="#cb9-9"></a>                process <span class="op">=</span> subprocess.Popen(</span>
<span id="cb9-10"><a href="#cb9-10"></a>                    <span class="ss">f"conda run -n gpu_env jupyter execute </span><span class="sc">{</span>ipynb_name<span class="sc">}</span><span class="ss">"</span>.split(), stdout<span class="op">=</span>subprocess.PIPE</span>
<span id="cb9-11"><a href="#cb9-11"></a>                    )</span>
<span id="cb9-12"><a href="#cb9-12"></a>                output, error <span class="op">=</span> process.communicate()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
<section id="the-main-loop" class="level3">
<h3 class="anchored" data-anchor-id="the-main-loop">The main loop</h3>
<p>Now I can use these methods to process all the items in the queue. As long as there are items to process, it will use <code>_advance_queue()</code> to process the one at the front of the queue. Next it will check if there are any new commands to process. Then it will check if the GPU state matches expectations. If there are any PIDs using the GPU that are <em>not</em> listed in the <code>nvidia_base_pids</code> list these will be stopped. Once the queue is exhausted, the script will stop.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1"></a>    <span class="kw">def</span> main(<span class="va">self</span>):</span>
<span id="cb10-2"><a href="#cb10-2"></a>        <span class="cf">while</span> <span class="bu">len</span>(<span class="va">self</span>.ipynb_names) <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb10-3"><a href="#cb10-3"></a>            <span class="bu">print</span>(<span class="ss">f'Running </span><span class="sc">{</span><span class="va">self</span><span class="sc">.</span>ipynb_names[<span class="dv">0</span>]<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb10-4"><a href="#cb10-4"></a>            <span class="va">self</span>._advance_queue()</span>
<span id="cb10-5"><a href="#cb10-5"></a>            <span class="co"># allow for external controls</span></span>
<span id="cb10-6"><a href="#cb10-6"></a>            <span class="va">self</span>._parse_ctrl_jsons()</span>
<span id="cb10-7"><a href="#cb10-7"></a>            <span class="va">self</span>._read_nvidia()</span>
<span id="cb10-8"><a href="#cb10-8"></a>            <span class="co"># kill all the processes that were not running at the start. </span></span>
<span id="cb10-9"><a href="#cb10-9"></a>            <span class="cf">for</span> gpu_pid <span class="kw">in</span> [e <span class="cf">for</span> e <span class="kw">in</span> <span class="va">self</span>.nvidia_state.keys() <span class="cf">if</span> e <span class="kw">not</span> <span class="kw">in</span> <span class="va">self</span>.nvidia_base_pids]:</span>
<span id="cb10-10"><a href="#cb10-10"></a>                subprocess.run(<span class="ss">f'kill -9 </span><span class="sc">{</span>gpu_pid<span class="sc">}</span><span class="ss">'</span>, shell<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb10-11"><a href="#cb10-11"></a>        <span class="bu">print</span>(<span class="st">'No more queued ipynbs. Exiting.'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<section id="all-together-and-possible-improvements" class="level4">
<h4 class="anchored" data-anchor-id="all-together-and-possible-improvements">All together (and possible improvements)</h4>
<p>This system works nicely for how quick it was to write up<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>. There are plenty of improvements that could be made. Suppose you wanted this to run in the background and idle until you added a new job to the queue. One could imaging changing the <code>main()</code> method to achieve this and extending <code>_parse_ctrl_jsons()</code> to get the system to stop idling and shut down. Or suppose you wanted to queue different file types or run notebooks in different environments – <code>_advance_queue()</code> could be extended to do this. Finally, suppose you don’t want to manually exempt PIDs that aren’t using much of the GPU’s resources. Each PID’s usage is available in the <code>nvidia_state</code> dictionary of dictionaries under <code>GPUMem</code>, so a threshold could be set.</p>
<p>These changes and other customization for your use case are left as an exercise for the reader.</p>
<p><em>Edit 2023-12-20:</em> I’ve added a background mode and option to begin the main loop directly on initialization.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1"></a><span class="im">import</span> os, subprocess, re, json,  time</span>
<span id="cb11-2"><a href="#cb11-2"></a><span class="kw">class</span> Scheduler():</span>
<span id="cb11-3"><a href="#cb11-3"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, background_mode <span class="op">=</span> <span class="va">False</span>, run_main <span class="op">=</span> <span class="va">False</span>):</span>
<span id="cb11-4"><a href="#cb11-4"></a>        <span class="va">self</span>.background_mode <span class="op">=</span> background_mode</span>
<span id="cb11-5"><a href="#cb11-5"></a>        <span class="va">self</span>.exit <span class="op">=</span> <span class="va">False</span></span>
<span id="cb11-6"><a href="#cb11-6"></a>        <span class="va">self</span>.nvidia_base_pids <span class="op">=</span> []</span>
<span id="cb11-7"><a href="#cb11-7"></a>        <span class="va">self</span>.nvidia_state <span class="op">=</span> {}</span>
<span id="cb11-8"><a href="#cb11-8"></a>        <span class="va">self</span>._init_nvidia()</span>
<span id="cb11-9"><a href="#cb11-9"></a>        <span class="va">self</span>.ipynb_names <span class="op">=</span> []</span>
<span id="cb11-10"><a href="#cb11-10"></a>        <span class="cf">if</span> run_main:</span>
<span id="cb11-11"><a href="#cb11-11"></a>            <span class="va">self</span>.main()</span>
<span id="cb11-12"><a href="#cb11-12"></a></span>
<span id="cb11-13"><a href="#cb11-13"></a></span>
<span id="cb11-14"><a href="#cb11-14"></a>    <span class="kw">def</span> _init_nvidia(<span class="va">self</span>):</span>
<span id="cb11-15"><a href="#cb11-15"></a>        <span class="va">self</span>._read_nvidia()</span>
<span id="cb11-16"><a href="#cb11-16"></a>        <span class="va">self</span>.nvidia_base_pids <span class="op">=</span> <span class="bu">list</span>(<span class="va">self</span>.nvidia_state.keys())</span>
<span id="cb11-17"><a href="#cb11-17"></a></span>
<span id="cb11-18"><a href="#cb11-18"></a>    <span class="kw">def</span> _read_nvidia(<span class="va">self</span>):    </span>
<span id="cb11-19"><a href="#cb11-19"></a>        x <span class="op">=</span> subprocess.run(<span class="st">"nvidia-smi"</span>, shell<span class="op">=</span><span class="va">True</span>, check<span class="op">=</span><span class="va">True</span>,  capture_output<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb11-20"><a href="#cb11-20"></a></span>
<span id="cb11-21"><a href="#cb11-21"></a>        x <span class="op">=</span> <span class="bu">str</span>(x).split(<span class="st">'</span><span class="ch">\\</span><span class="st">n'</span>)</span>
<span id="cb11-22"><a href="#cb11-22"></a></span>
<span id="cb11-23"><a href="#cb11-23"></a>        table_blocks <span class="op">=</span> [i <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(x)) <span class="cf">if</span> re.match(<span class="st">'.+===+.+'</span>, x[i])]</span>
<span id="cb11-24"><a href="#cb11-24"></a>        table_breaks <span class="op">=</span> [i <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(x)) <span class="cf">if</span> re.match(<span class="st">'.+---+.+'</span>, x[i])]</span>
<span id="cb11-25"><a href="#cb11-25"></a>        process_row  <span class="op">=</span> [i <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(x)) <span class="cf">if</span> re.match(<span class="st">'.+ Processes: .+'</span>, x[i])]</span>
<span id="cb11-26"><a href="#cb11-26"></a>        start_line <span class="op">=</span> [i <span class="cf">for</span> i <span class="kw">in</span> table_blocks <span class="cf">if</span> i <span class="op">&gt;</span> process_row[<span class="dv">0</span>] ][<span class="dv">0</span>]</span>
<span id="cb11-27"><a href="#cb11-27"></a>        end_line   <span class="op">=</span> [i <span class="cf">for</span> i <span class="kw">in</span> table_breaks <span class="cf">if</span> i <span class="op">&gt;</span> process_row[<span class="dv">0</span>] ][<span class="dv">0</span>]</span>
<span id="cb11-28"><a href="#cb11-28"></a></span>
<span id="cb11-29"><a href="#cb11-29"></a>        running_processes <span class="op">=</span> [x[i] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(start_line<span class="op">+</span><span class="dv">1</span>, end_line)]</span>
<span id="cb11-30"><a href="#cb11-30"></a>        running_processes <span class="op">=</span> [<span class="bu">dict</span>(<span class="bu">zip</span>(</span>
<span id="cb11-31"><a href="#cb11-31"></a>            [<span class="st">'GPU'</span>, <span class="st">'GI'</span>, <span class="st">'CI'</span>, <span class="st">'PID'</span>, <span class="st">'Type'</span>, <span class="st">'ProcessName'</span>, <span class="st">'GPUMem'</span>],</span>
<span id="cb11-32"><a href="#cb11-32"></a>            [e <span class="cf">for</span> e <span class="kw">in</span> line.strip(<span class="st">'|'</span>).split(<span class="st">' '</span>) <span class="cf">if</span> e <span class="op">!=</span> <span class="st">''</span>])) <span class="cf">for</span> line <span class="kw">in</span> running_processes]</span>
<span id="cb11-33"><a href="#cb11-33"></a></span>
<span id="cb11-34"><a href="#cb11-34"></a>        <span class="cf">for</span> e <span class="kw">in</span> running_processes:</span>
<span id="cb11-35"><a href="#cb11-35"></a>            <span class="va">self</span>.nvidia_state[e[<span class="st">'PID'</span>]] <span class="op">=</span> e</span>
<span id="cb11-36"><a href="#cb11-36"></a>    </span>
<span id="cb11-37"><a href="#cb11-37"></a>    <span class="kw">def</span> _parse_ctrl_jsons(<span class="va">self</span>):</span>
<span id="cb11-38"><a href="#cb11-38"></a>        ctrl_files <span class="op">=</span> [e <span class="cf">for</span> e <span class="kw">in</span> os.listdir(<span class="st">'./SchedulerFiles/'</span>) <span class="cf">if</span> (re.match(<span class="st">'ctrl.json'</span>, e) <span class="kw">or</span> re.match(<span class="st">'ctrl\d+.json'</span>, e))]</span>
<span id="cb11-39"><a href="#cb11-39"></a>        <span class="cf">if</span> <span class="bu">len</span>(ctrl_files) <span class="op">&gt;=</span> <span class="dv">1</span>:</span>
<span id="cb11-40"><a href="#cb11-40"></a>            <span class="cf">for</span> ctrl_file <span class="kw">in</span> ctrl_files:            </span>
<span id="cb11-41"><a href="#cb11-41"></a>                <span class="cf">with</span> <span class="bu">open</span>(<span class="st">'./SchedulerFiles/'</span><span class="op">+</span>ctrl_file, <span class="st">'r'</span>) <span class="im">as</span> f:</span>
<span id="cb11-42"><a href="#cb11-42"></a>                    data <span class="op">=</span> json.load(f)</span>
<span id="cb11-43"><a href="#cb11-43"></a></span>
<span id="cb11-44"><a href="#cb11-44"></a>                keys <span class="op">=</span> <span class="bu">tuple</span>(data.keys())</span>
<span id="cb11-45"><a href="#cb11-45"></a></span>
<span id="cb11-46"><a href="#cb11-46"></a>                <span class="cf">if</span> <span class="st">'info'</span> <span class="kw">in</span> keys:</span>
<span id="cb11-47"><a href="#cb11-47"></a>                    <span class="bu">print</span>(<span class="st">"""</span></span>
<span id="cb11-48"><a href="#cb11-48"></a><span class="st">This scheduling tool uses json files to modify its state while running. </span></span>
<span id="cb11-49"><a href="#cb11-49"></a><span class="st">It will look for json files beginning with 'ctrl' and containing 0 or more digits in </span></span>
<span id="cb11-50"><a href="#cb11-50"></a><span class="st">./SchedulerFiles/ and then run each. This json should be interpretable as a python dictionary.</span></span>
<span id="cb11-51"><a href="#cb11-51"></a><span class="st">Files are interpreted in the order of the keys but conflicting orders are not recommended. </span></span>
<span id="cb11-52"><a href="#cb11-52"></a><span class="st">Example file:</span></span>
<span id="cb11-53"><a href="#cb11-53"></a><span class="st">{</span></span>
<span id="cb11-54"><a href="#cb11-54"></a><span class="st">    'info'                :[],                            -&gt; Print this message</span></span>
<span id="cb11-55"><a href="#cb11-55"></a><span class="st">    'nvidia_base_pids_add':['40082'],                     -&gt; Prevent a specific PID from being autoclosed. (e.g. if you're running a gpu session interactively)</span></span>
<span id="cb11-56"><a href="#cb11-56"></a><span class="st">    'nvidia_base_pids_del':['40082'],                     -&gt; Allow a specific PID to be autoclosed.</span></span>
<span id="cb11-57"><a href="#cb11-57"></a><span class="st">    'ipynb_names_read'    :[],                            -&gt; Print currently queued notebooks.</span></span>
<span id="cb11-58"><a href="#cb11-58"></a><span class="st">    'ipynb_names_add'     :['SchedulerTestScript.ipynb'], -&gt; Add a notebook (to the end) of the queue</span></span>
<span id="cb11-59"><a href="#cb11-59"></a><span class="st">    'ipynb_names_next'    :['SchedulerTestScript.ipynb'], -&gt; Add a notebook to the beginning of the queue (does not need to be in the queue)</span></span>
<span id="cb11-60"><a href="#cb11-60"></a><span class="st">    'ipynb_names_del'     :['SchedulerTestScript.ipynb'], -&gt; Remove a notebook from the queue</span></span>
<span id="cb11-61"><a href="#cb11-61"></a><span class="st">    'background_mode'     :['True'],                      -&gt; Set to idle if there are no notebooks in the queue</span></span>
<span id="cb11-62"><a href="#cb11-62"></a><span class="st">    'exit'                :[],                            -&gt; Remove a notebook from the queue</span></span>
<span id="cb11-63"><a href="#cb11-63"></a><span class="st">                          </span></span>
<span id="cb11-64"><a href="#cb11-64"></a><span class="st">}"""</span>)</span>
<span id="cb11-65"><a href="#cb11-65"></a>                <span class="cf">for</span> key <span class="kw">in</span> keys:</span>
<span id="cb11-66"><a href="#cb11-66"></a>                    <span class="cf">if</span> <span class="st">'nvidia_base_pids_add'</span> <span class="op">==</span> key:</span>
<span id="cb11-67"><a href="#cb11-67"></a>                        <span class="va">self</span>.nvidia_base_pids <span class="op">+=</span> data[key]</span>
<span id="cb11-68"><a href="#cb11-68"></a>                    <span class="cf">if</span> <span class="st">'nvidia_base_pids_del'</span> <span class="op">==</span> key:</span>
<span id="cb11-69"><a href="#cb11-69"></a>                        <span class="va">self</span>.nvidia_base_pids <span class="op">=</span> [e <span class="cf">for</span> e <span class="kw">in</span> <span class="va">self</span>.nvidia_base_pids <span class="cf">if</span> e <span class="kw">not</span> <span class="kw">in</span> data[key]]</span>
<span id="cb11-70"><a href="#cb11-70"></a>                    <span class="cf">if</span> <span class="st">'ipynb_names_read'</span> <span class="op">==</span> key:</span>
<span id="cb11-71"><a href="#cb11-71"></a>                        <span class="bu">print</span>(<span class="va">self</span>.ipynb_names)</span>
<span id="cb11-72"><a href="#cb11-72"></a>                    <span class="cf">if</span> <span class="st">'ipynb_names_add'</span> <span class="op">==</span> key:</span>
<span id="cb11-73"><a href="#cb11-73"></a>                        <span class="va">self</span>.ipynb_names <span class="op">+=</span> data[key]</span>
<span id="cb11-74"><a href="#cb11-74"></a>                    <span class="cf">if</span> <span class="st">'ipynb_names_next'</span> <span class="op">==</span> key:</span>
<span id="cb11-75"><a href="#cb11-75"></a>                        <span class="co"># technically this could be used to add files and set them to first</span></span>
<span id="cb11-76"><a href="#cb11-76"></a>                        <span class="va">self</span>.ipynb_names <span class="op">=</span> data[key]<span class="op">+</span>[e <span class="cf">for</span> e <span class="kw">in</span> <span class="va">self</span>.ipynb_names  <span class="cf">if</span> e <span class="op">!=</span> data[key]]</span>
<span id="cb11-77"><a href="#cb11-77"></a>                    <span class="cf">if</span> <span class="st">'ipynb_names_del'</span> <span class="op">==</span> key:</span>
<span id="cb11-78"><a href="#cb11-78"></a>                        <span class="va">self</span>.ipynb_names <span class="op">=</span> [e <span class="cf">for</span> e <span class="kw">in</span> <span class="va">self</span>.ipynb_names <span class="cf">if</span> e <span class="op">!=</span> data[key]]</span>
<span id="cb11-79"><a href="#cb11-79"></a>                    <span class="cf">if</span> <span class="st">'background_mode'</span> <span class="op">==</span> key:</span>
<span id="cb11-80"><a href="#cb11-80"></a>                        dat <span class="op">=</span> data[key][<span class="dv">0</span>]</span>
<span id="cb11-81"><a href="#cb11-81"></a>                        <span class="cf">if</span> <span class="bu">type</span>(dat) <span class="op">==</span> <span class="bu">str</span>:</span>
<span id="cb11-82"><a href="#cb11-82"></a>                            <span class="cf">if</span> dat.lower() <span class="op">==</span> <span class="st">'true'</span>:</span>
<span id="cb11-83"><a href="#cb11-83"></a>                                dat <span class="op">=</span> <span class="va">True</span></span>
<span id="cb11-84"><a href="#cb11-84"></a>                            <span class="cf">elif</span> dat.lower() <span class="op">==</span> <span class="st">'false'</span>:</span>
<span id="cb11-85"><a href="#cb11-85"></a>                                dat <span class="op">=</span> <span class="va">False</span></span>
<span id="cb11-86"><a href="#cb11-86"></a>                            <span class="cf">else</span>:</span>
<span id="cb11-87"><a href="#cb11-87"></a>                                <span class="bu">print</span>(<span class="ss">f'</span><span class="sc">{</span>dat<span class="sc">}</span><span class="ss"> not interpretable as True or False'</span>)</span>
<span id="cb11-88"><a href="#cb11-88"></a>                        <span class="cf">if</span> <span class="bu">type</span>(dat) <span class="op">==</span> <span class="bu">bool</span>:</span>
<span id="cb11-89"><a href="#cb11-89"></a>                            <span class="va">self</span>.background_mode <span class="op">=</span> dat</span>
<span id="cb11-90"><a href="#cb11-90"></a>                    <span class="cf">if</span> <span class="st">'exit'</span> <span class="op">==</span> key:</span>
<span id="cb11-91"><a href="#cb11-91"></a>                        <span class="va">self</span>.exit <span class="op">=</span> <span class="va">True</span></span>
<span id="cb11-92"><a href="#cb11-92"></a></span>
<span id="cb11-93"><a href="#cb11-93"></a>                <span class="co"># remove the file</span></span>
<span id="cb11-94"><a href="#cb11-94"></a>                os.unlink(<span class="st">'./SchedulerFiles/'</span><span class="op">+</span>ctrl_file)</span>
<span id="cb11-95"><a href="#cb11-95"></a></span>
<span id="cb11-96"><a href="#cb11-96"></a>    <span class="kw">def</span> _advance_queue(<span class="va">self</span>):</span>
<span id="cb11-97"><a href="#cb11-97"></a>        <span class="cf">if</span> <span class="bu">len</span>(<span class="va">self</span>.ipynb_names) <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb11-98"><a href="#cb11-98"></a>            <span class="cf">pass</span></span>
<span id="cb11-99"><a href="#cb11-99"></a>        <span class="cf">else</span>:</span>
<span id="cb11-100"><a href="#cb11-100"></a>            ipynb_name <span class="op">=</span> <span class="va">self</span>.ipynb_names.pop(<span class="dv">0</span>)</span>
<span id="cb11-101"><a href="#cb11-101"></a>            <span class="cf">if</span> os.path.exists(ipynb_name) <span class="op">==</span> <span class="va">False</span>:</span>
<span id="cb11-102"><a href="#cb11-102"></a>                <span class="cf">pass</span></span>
<span id="cb11-103"><a href="#cb11-103"></a>            <span class="cf">else</span>:</span>
<span id="cb11-104"><a href="#cb11-104"></a>                process <span class="op">=</span> subprocess.Popen(</span>
<span id="cb11-105"><a href="#cb11-105"></a>                    <span class="ss">f"conda run -n fastai jupyter execute </span><span class="sc">{</span>ipynb_name<span class="sc">}</span><span class="ss">"</span>.split(), stdout<span class="op">=</span>subprocess.PIPE</span>
<span id="cb11-106"><a href="#cb11-106"></a>                    )</span>
<span id="cb11-107"><a href="#cb11-107"></a>                output, error <span class="op">=</span> process.communicate()</span>
<span id="cb11-108"><a href="#cb11-108"></a></span>
<span id="cb11-109"><a href="#cb11-109"></a>      <span class="kw">def</span> main(<span class="va">self</span>):</span>
<span id="cb11-110"><a href="#cb11-110"></a>        <span class="cf">while</span> ((<span class="bu">len</span>(<span class="va">self</span>.ipynb_names) <span class="op">&gt;</span> <span class="dv">0</span>) <span class="kw">or</span> (<span class="va">self</span>.background_mode)):</span>
<span id="cb11-111"><a href="#cb11-111"></a>            <span class="cf">if</span> ((<span class="bu">len</span>(<span class="va">self</span>.ipynb_names) <span class="op">==</span> <span class="dv">0</span>) <span class="kw">and</span> (<span class="va">self</span>.background_mode)):</span>
<span id="cb11-112"><a href="#cb11-112"></a>                <span class="co"># if idling in background mode wait to check for new commands. </span></span>
<span id="cb11-113"><a href="#cb11-113"></a>                time.sleep(<span class="dv">10</span>)</span>
<span id="cb11-114"><a href="#cb11-114"></a>                <span class="co"># While idling any new gpu PIDs should be ignored.</span></span>
<span id="cb11-115"><a href="#cb11-115"></a>                <span class="va">self</span>._init_nvidia()</span>
<span id="cb11-116"><a href="#cb11-116"></a></span>
<span id="cb11-117"><a href="#cb11-117"></a>            <span class="cf">if</span> <span class="va">self</span>.exit: <span class="cf">break</span>        </span>
<span id="cb11-118"><a href="#cb11-118"></a>            <span class="va">self</span>._parse_ctrl_jsons()</span>
<span id="cb11-119"><a href="#cb11-119"></a></span>
<span id="cb11-120"><a href="#cb11-120"></a>            <span class="cf">if</span> <span class="va">self</span>.exit: <span class="cf">break</span></span>
<span id="cb11-121"><a href="#cb11-121"></a>            <span class="cf">if</span> (<span class="bu">len</span>(<span class="va">self</span>.ipynb_names) <span class="op">&gt;</span> <span class="dv">0</span>):</span>
<span id="cb11-122"><a href="#cb11-122"></a>                <span class="bu">print</span>(<span class="ss">f'Running </span><span class="sc">{</span><span class="va">self</span><span class="sc">.</span>ipynb_names[<span class="dv">0</span>]<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb11-123"><a href="#cb11-123"></a>                <span class="va">self</span>._advance_queue()</span>
<span id="cb11-124"><a href="#cb11-124"></a></span>
<span id="cb11-125"><a href="#cb11-125"></a>                <span class="co"># allow for external controls</span></span>
<span id="cb11-126"><a href="#cb11-126"></a>                <span class="va">self</span>._parse_ctrl_jsons()</span>
<span id="cb11-127"><a href="#cb11-127"></a>                <span class="cf">if</span> <span class="va">self</span>.exit: <span class="cf">break</span>        </span>
<span id="cb11-128"><a href="#cb11-128"></a></span>
<span id="cb11-129"><a href="#cb11-129"></a>                <span class="va">self</span>._read_nvidia()</span>
<span id="cb11-130"><a href="#cb11-130"></a>                <span class="co"># kill all the processes that were not running at the start. </span></span>
<span id="cb11-131"><a href="#cb11-131"></a>                <span class="cf">for</span> gpu_pid <span class="kw">in</span> [e <span class="cf">for</span> e <span class="kw">in</span> <span class="va">self</span>.nvidia_state.keys() <span class="cf">if</span> e <span class="kw">not</span> <span class="kw">in</span> <span class="va">self</span>.nvidia_base_pids]:</span>
<span id="cb11-132"><a href="#cb11-132"></a>                    subprocess.run(<span class="ss">f'kill -9 </span><span class="sc">{</span>gpu_pid<span class="sc">}</span><span class="ss">'</span>, shell<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb11-133"><a href="#cb11-133"></a>            <span class="bu">print</span>(<span class="ss">f'Running </span><span class="sc">{</span>time<span class="sc">.</span>strftime(<span class="st">"%Y-%m-</span><span class="sc">%d</span><span class="st"> %H:%M:%S"</span>, time.localtime())<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb11-134"><a href="#cb11-134"></a>        <span class="bu">print</span>(    <span class="ss">f'Exiting </span><span class="sc">{</span>time<span class="sc">.</span>strftime(<span class="st">"%Y-%m-</span><span class="sc">%d</span><span class="st"> %H:%M:%S"</span>, time.localtime())<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb11-135"><a href="#cb11-135"></a>            </span>
<span id="cb11-136"><a href="#cb11-136"></a></span>
<span id="cb11-137"><a href="#cb11-137"></a><span class="co"># Example usage: Start in background mode. While in background mode new gpu processes shouldn't be killed.</span></span>
<span id="cb11-138"><a href="#cb11-138"></a><span class="co"># shlr = Scheduler(background_mode = True, run_main=True)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>


</section>
</section>
</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>Indeed, it is named after that slurm.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>This is less useful than running jobs as soon as resources are available. However, it does mean that implementing the system is a lot easier. The goal is to get most of the benefit quickly, then return and replace or extend this system once my needs outgrow it.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>If there are over 10 control files then they might not run in the order the user expects (e.g.&nbsp;ctrl10 would be run between ctrl1 and ctrl2) but I don’t anticipate issuing that many commands at once.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>For formatting this message is omitted here. It is:</p>
<pre><code>This scheduling tool uses json files to modify its state while running. 
It will look for json files beginning with 'ctrl' and containing 0 or more digits in 
./SchedulerFiles/ and then run each. This json should be interpretable as a python dictionary.
Files are interpreted in the order of the keys but conflicting orders are not recommended. 
Example file:
{
    'info'                :[],                            -&gt; Print this message
    'nvidia_base_pids_add':['40082'],                     -&gt; Prevent a specific PID from being autoclosed. (e.g. if you're running a gpu session interactively)
    'nvidia_base_pids_del':['40082'],                     -&gt; Allow a specific PID to be autoclosed.
    'ipynb_names_read'    :[],                            -&gt; Print currently queued notebooks.
    'ipynb_names_add'     :['SchedulerTestScript.ipynb'], -&gt; Add a notebook (to the end) of the queue
    'ipynb_names_next'    :['SchedulerTestScript.ipynb'], -&gt; Add a notebook to the beginning of the queue (does not need to be in the queue)
    'ipynb_names_del'     :['SchedulerTestScript.ipynb'], -&gt; Remove a notebook from the queue
}</code></pre>
<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></li>
<li id="fn5"><p>Writing this explanation took longer than writing the code.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p><a href="mailto:hello@danielkick.com">Contact Daniel</a></p>
</div>
    <div class="nav-footer-right">
<p><a href="https://github.com/danielkick/danielkick.github.io">View the Source</a></p>
</div>
  </div>
</footer>




</body></html>