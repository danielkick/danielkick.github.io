<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.313">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Daniel Kick">
<meta name="dcterms.date" content="2023-09-15">

<title>Making a “Visible” Neural Network</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<script src="../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../index.html">
 <span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../posts/DanielKick/index.html">
 <span class="menu-text">Posts</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="https://github.com/danielkick/Resume/blob/main/Resume.pdf">
 <span class="menu-text">Resume</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://github.com/danielkick/Resume/blob/main/Curriculum-Vitae.pdf">
 <span class="menu-text">CV</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/danielkick"><i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/daniel-kick-5a449b9a/"><i class="bi bi-linkedin" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
              <div class="quarto-toggle-container">
                  <a href="" class="quarto-color-scheme-toggle nav-link" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
              </div>
              <div id="quarto-search" class="" title="Search"></div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Making a “Visible” Neural Network</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">code</div>
                <div class="quarto-category">advanced</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Daniel Kick </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">September 15, 2023</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<section id="whats-a-visual-neural-network" class="level2">
<h2 class="anchored" data-anchor-id="whats-a-visual-neural-network">What’s a visual neural network?</h2>
<p>In most neural networks, neurons are not parametric in the same way that linear models are. In a image recognition model there may be neuron which <em>functions</em> to detects edges but when the model is set up initially one can’t point to a neuron and say what it will do or represent. This can make interpreting the weights in a model tricky.</p>
<p>Visible neural networks (VNN) are one way to get around this problem by making the structure of a model reflect the process being modeled. In a VNN, influential sub-components may be interpreted as implicating the process they represent as being important. Within biology VNNs have been used by <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5882547/">Ma et al.&nbsp;2018</a> and <a href="https://www.nature.com/articles/s42003-021-02622-z">Hilten et al.&nbsp;2021</a> working in yeast and humans respectively (in the later mixed performance, seemingly based on trait complexity).</p>
</section>
<section id="a-hypothetical-gene-network" class="level2">
<h2 class="anchored" data-anchor-id="a-hypothetical-gene-network">A hypothetical gene network</h2>
<p>Before scaling to representing gene networks, I built a simple test case and will walk through it below, with all the necessary code (but some of it hidden<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> for brevity).</p>
<p><img src="GraphBasic.png" class="img-fluid"></p>
<p>Here we have a hypothetical network which involves two genes (<code>a1_input</code>, <code>a2_input</code>), variants of which affect some initial processes (<code>b1</code>, <code>b2</code>), which in turn affect a second set of processes (<code>c1</code>, <code>c2</code>). I’ll use these last processes to predict my trait of interest (<code>y_hat</code>).</p>
<p>This is a directed acyclic graph, meaning that processes have an order (the arrows) and there are no loops (<code>c1</code> doesn’t some how change <code>a1_input</code>). The model I’d like to end up with is a neural network with a structure that mirrors this graph <a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> with each node representing one or more layers of neurons.</p>
<p>Beginning with the end in mind, I need a way to specify: 1. The data the graph operates on 1. The process graph and each node’s attributes 1. How to “move” through the graph</p>
</section>
<section id="the-data-itself" class="level2">
<h2 class="anchored" data-anchor-id="the-data-itself">1. The data itself</h2>
<p>My example trait, <span class="math inline">\(y\)</span> is either 0 or 1 (plus a little noise). It’s controlled by two genes which are represented as tensor<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> containing values for each possible nucleotide (ACGT) for each SNP measured in the gene. Conveniently, both genes either contain all 0’s or all 1’s and when there are only 0’s <span class="math inline">\(y\)</span> will be around 0 (and the same for 1).</p>
<p>This of course means that in this population <em>no nucleotides</em> (all 0s) were observed or <em>all nucleotides</em> (all 1s) were simultaneously observed. Don’t ask me how this is possible 🤔. For real data these values would be probability of seeing a given nucelotide so “A” might be <code>[1, 0, 0, 0]</code><a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>.</p>
<div class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a>n_obs <span class="op">=</span> <span class="dv">100</span> <span class="co"># 100 obs for each group</span></span>
<span id="cb1-2"><a href="#cb1-2"></a>y_true <span class="op">=</span> torch.from_numpy(np.concatenate([</span>
<span id="cb1-3"><a href="#cb1-3"></a>        np.zeros((n_obs, )),</span>
<span id="cb1-4"><a href="#cb1-4"></a>        np.ones( (n_obs, ))], <span class="dv">0</span>)) <span class="op">+</span> <span class="fl">.1</span><span class="op">*</span> torch.rand(<span class="dv">2</span><span class="op">*</span>n_obs,)</span>
<span id="cb1-5"><a href="#cb1-5"></a>        </span>
<span id="cb1-6"><a href="#cb1-6"></a>input_tensor_dict <span class="op">=</span> {</span>
<span id="cb1-7"><a href="#cb1-7"></a>    <span class="st">'a1_input'</span>: torch.from_numpy(np.concatenate([</span>
<span id="cb1-8"><a href="#cb1-8"></a>        np.zeros((n_obs, <span class="dv">4</span>, <span class="dv">3</span>)),</span>
<span id="cb1-9"><a href="#cb1-9"></a>        np.ones( (n_obs, <span class="dv">4</span>, <span class="dv">3</span>))], <span class="dv">0</span>)),</span>
<span id="cb1-10"><a href="#cb1-10"></a>    <span class="st">'a2_input'</span>: torch.from_numpy(np.concatenate([</span>
<span id="cb1-11"><a href="#cb1-11"></a>        np.zeros((n_obs, <span class="dv">4</span>, <span class="dv">2</span>)),  </span>
<span id="cb1-12"><a href="#cb1-12"></a>        np.ones( (n_obs, <span class="dv">4</span>, <span class="dv">2</span>))], <span class="dv">0</span>))}</span>
<span id="cb1-13"><a href="#cb1-13"></a></span>
<span id="cb1-14"><a href="#cb1-14"></a>x_list_temp <span class="op">=</span> [input_tensor_dict[key].to(torch.<span class="bu">float</span>) <span class="cf">for</span> key <span class="kw">in</span> input_tensor_dict.keys()]</span>
<span id="cb1-15"><a href="#cb1-15"></a>x_list_temp</span>
<span id="cb1-16"><a href="#cb1-16"></a><span class="co"># output</span></span>
<span id="cb1-17"><a href="#cb1-17"></a>                        <span class="co"># Probability of</span></span>
<span id="cb1-18"><a href="#cb1-18"></a>[tensor([[[<span class="fl">0.</span>, <span class="fl">0.</span>, <span class="fl">0.</span>], <span class="co"># A</span></span>
<span id="cb1-19"><a href="#cb1-19"></a>          [<span class="fl">0.</span>, <span class="fl">0.</span>, <span class="fl">0.</span>], <span class="co"># C</span></span>
<span id="cb1-20"><a href="#cb1-20"></a>          [<span class="fl">0.</span>, <span class="fl">0.</span>, <span class="fl">0.</span>], <span class="co"># G</span></span>
<span id="cb1-21"><a href="#cb1-21"></a>          [<span class="fl">0.</span>, <span class="fl">0.</span>, <span class="fl">0.</span>]],<span class="co"># T</span></span>
<span id="cb1-22"><a href="#cb1-22"></a></span>
<span id="cb1-23"><a href="#cb1-23"></a>         ...,</span>
<span id="cb1-24"><a href="#cb1-24"></a></span>
<span id="cb1-25"><a href="#cb1-25"></a>         [[<span class="fl">1.</span>, <span class="fl">1.</span>, <span class="fl">1.</span>],</span>
<span id="cb1-26"><a href="#cb1-26"></a>          [<span class="fl">1.</span>, <span class="fl">1.</span>, <span class="fl">1.</span>],</span>
<span id="cb1-27"><a href="#cb1-27"></a>          [<span class="fl">1.</span>, <span class="fl">1.</span>, <span class="fl">1.</span>],</span>
<span id="cb1-28"><a href="#cb1-28"></a>          [<span class="fl">1.</span>, <span class="fl">1.</span>, <span class="fl">1.</span>]]]),</span>
<span id="cb1-29"><a href="#cb1-29"></a></span>
<span id="cb1-30"><a href="#cb1-30"></a> tensor([[[<span class="fl">0.</span>, <span class="fl">0.</span>],</span>
<span id="cb1-31"><a href="#cb1-31"></a>          [<span class="fl">0.</span>, <span class="fl">0.</span>],</span>
<span id="cb1-32"><a href="#cb1-32"></a>          [<span class="fl">0.</span>, <span class="fl">0.</span>],</span>
<span id="cb1-33"><a href="#cb1-33"></a>          [<span class="fl">0.</span>, <span class="fl">0.</span>]],</span>
<span id="cb1-34"><a href="#cb1-34"></a></span>
<span id="cb1-35"><a href="#cb1-35"></a>         ...,</span>
<span id="cb1-36"><a href="#cb1-36"></a></span>
<span id="cb1-37"><a href="#cb1-37"></a>         [[<span class="fl">1.</span>, <span class="fl">1.</span>],</span>
<span id="cb1-38"><a href="#cb1-38"></a>          [<span class="fl">1.</span>, <span class="fl">1.</span>],</span>
<span id="cb1-39"><a href="#cb1-39"></a>          [<span class="fl">1.</span>, <span class="fl">1.</span>],</span>
<span id="cb1-40"><a href="#cb1-40"></a>          [<span class="fl">1.</span>, <span class="fl">1.</span>]]])]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Then this data can be packaged nicely in a <code>DataLoader</code><a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>. This will retrieve the trait (<code>y</code>) and SNPs for each gene (in <code>x_list</code>) for 20 observations at a time.</p>
<div class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1"></a>training_dataloader <span class="op">=</span> DataLoader(</span>
<span id="cb2-2"><a href="#cb2-2"></a>  ListDataset(</span>
<span id="cb2-3"><a href="#cb2-3"></a>    y <span class="op">=</span> y_true[:, <span class="va">None</span>].to(torch.float32), <span class="co"># Set as 32 bit float to match network</span></span>
<span id="cb2-4"><a href="#cb2-4"></a>    x_list <span class="op">=</span> [e.to(torch.float32) <span class="cf">for</span> e <span class="kw">in</span> x_list_temp]),</span>
<span id="cb2-5"><a href="#cb2-5"></a>    batch_size <span class="op">=</span> <span class="dv">20</span>,</span>
<span id="cb2-6"><a href="#cb2-6"></a>    shuffle <span class="op">=</span> <span class="va">True</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="defining-the-graph" class="level2">
<h2 class="anchored" data-anchor-id="defining-the-graph">2. Defining the graph</h2>
<p>The structure of a graph can be nicely represented as a python dictionary so I’ll begin with that:</p>
<div class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1"></a>node_connections <span class="op">=</span> {</span>
<span id="cb3-2"><a href="#cb3-2"></a>  <span class="st">'y_hat'</span>:[<span class="st">'c1'</span>, <span class="st">'c2'</span>],</span>
<span id="cb3-3"><a href="#cb3-3"></a>  <span class="st">'c1'</span>:[<span class="st">'b1'</span>],</span>
<span id="cb3-4"><a href="#cb3-4"></a>  <span class="st">'c2'</span>:[<span class="st">'b2'</span>],</span>
<span id="cb3-5"><a href="#cb3-5"></a>  <span class="st">'b1'</span>:[<span class="st">'a1_input'</span>, <span class="st">'b2'</span>],</span>
<span id="cb3-6"><a href="#cb3-6"></a>  <span class="st">'b2'</span>:[<span class="st">'a2_input'</span>],</span>
<span id="cb3-7"><a href="#cb3-7"></a>  <span class="st">'a1_input'</span>: [],</span>
<span id="cb3-8"><a href="#cb3-8"></a>  <span class="st">'a2_input'</span>: []</span>
<span id="cb3-9"><a href="#cb3-9"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Each node will have an input and output size stored in a dictionary. The output sizes are easy, all nodes will have the same size except for the last node, which has predicts y, which will have a size of 1.</p>
<div class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1"></a>node_list <span class="op">=</span> <span class="bu">list</span>(node_connections.keys())</span>
<span id="cb4-2"><a href="#cb4-2"></a></span>
<span id="cb4-3"><a href="#cb4-3"></a>default_output_size <span class="op">=</span> <span class="dv">20</span></span>
<span id="cb4-4"><a href="#cb4-4"></a>output_size_dict <span class="op">=</span> <span class="bu">dict</span>(<span class="bu">zip</span>(node_list, </span>
<span id="cb4-5"><a href="#cb4-5"></a>                        [default_output_size <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(node_list))]))</span>
<span id="cb4-6"><a href="#cb4-6"></a>output_size_dict[<span class="st">'y_hat'</span>] <span class="op">=</span> <span class="dv">1</span> </span>
<span id="cb4-7"><a href="#cb4-7"></a>output_size_dict</span>
<span id="cb4-8"><a href="#cb4-8"></a><span class="co"># output</span></span>
<span id="cb4-9"><a href="#cb4-9"></a>{<span class="st">'a1_input'</span>: <span class="dv">20</span>,</span>
<span id="cb4-10"><a href="#cb4-10"></a> <span class="st">'a2_input'</span>: <span class="dv">20</span>,</span>
<span id="cb4-11"><a href="#cb4-11"></a> <span class="st">'b1'</span>: <span class="dv">20</span>,</span>
<span id="cb4-12"><a href="#cb4-12"></a> <span class="st">'b2'</span>: <span class="dv">20</span>,</span>
<span id="cb4-13"><a href="#cb4-13"></a> <span class="st">'c1'</span>: <span class="dv">20</span>,</span>
<span id="cb4-14"><a href="#cb4-14"></a> <span class="st">'c2'</span>: <span class="dv">20</span>,</span>
<span id="cb4-15"><a href="#cb4-15"></a> <span class="st">'y_hat'</span>: <span class="dv">1</span>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The input sizes are a little trickier. A node’s input should be the number of SNPs in a gene (if it’s an input node) or the sum of the outputs of the nodes on which it depends (e.g.&nbsp;<code>y_hat</code>’s input size is the sum of <code>c1</code> and <code>c2</code>’s outputs). To do this, I’m going to copy the dictionary with all the connections between nodes, then swap the node names for their output sizes. Summing the list of these output values will be the required input size. Data nodes don’t depend on input from other nodes, so those will have an input shape of 0.</p>
<div class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1"></a>input_size_dict <span class="op">=</span> node_connections.copy()</span>
<span id="cb5-2"><a href="#cb5-2"></a></span>
<span id="cb5-3"><a href="#cb5-3"></a>no_dependants <span class="op">=</span> [e <span class="cf">for</span> e <span class="kw">in</span> node_connections.keys() <span class="cf">if</span> node_connections[e] <span class="op">==</span> []]</span>
<span id="cb5-4"><a href="#cb5-4"></a></span>
<span id="cb5-5"><a href="#cb5-5"></a><span class="co"># use the expected output sizes from `output_size_dict` to fill in the non-data sizes</span></span>
<span id="cb5-6"><a href="#cb5-6"></a>tensor_ndim <span class="op">=</span> <span class="bu">len</span>(input_tensor_dict[<span class="bu">list</span>(input_tensor_dict.keys())[<span class="dv">0</span>]].shape)</span>
<span id="cb5-7"><a href="#cb5-7"></a><span class="cf">for</span> e <span class="kw">in</span> tqdm(input_size_dict.keys()):</span>
<span id="cb5-8"><a href="#cb5-8"></a>    <span class="co"># overwrite named connections with the output size of those connections</span></span>
<span id="cb5-9"><a href="#cb5-9"></a>    <span class="co"># if the entry is in no_dependants it's data so it's size needs to be grabbed from the input_tensor_dict</span></span>
<span id="cb5-10"><a href="#cb5-10"></a>    input_size_dict[e] <span class="op">=</span> [</span>
<span id="cb5-11"><a href="#cb5-11"></a>        (<span class="bu">list</span>(input_tensor_dict[ee].shape)[<span class="dv">1</span>]<span class="op">*</span><span class="bu">list</span>(input_tensor_dict[ee].shape)[<span class="dv">2</span>]) </span>
<span id="cb5-12"><a href="#cb5-12"></a>        <span class="cf">if</span> ee <span class="kw">in</span> no_dependants</span>
<span id="cb5-13"><a href="#cb5-13"></a>        <span class="cf">else</span> output_size_dict[ee] <span class="cf">for</span> ee <span class="kw">in</span> input_size_dict[e]]</span>
<span id="cb5-14"><a href="#cb5-14"></a></span>
<span id="cb5-15"><a href="#cb5-15"></a><span class="co"># Now walk over entries and overwrite with the sum of the inputs</span></span>
<span id="cb5-16"><a href="#cb5-16"></a><span class="cf">for</span> e <span class="kw">in</span> tqdm(input_size_dict.keys()):</span>
<span id="cb5-17"><a href="#cb5-17"></a>    input_size_dict[e] <span class="op">=</span> np.<span class="bu">sum</span>(input_size_dict[e])</span>
<span id="cb5-18"><a href="#cb5-18"></a>    </span>
<span id="cb5-19"><a href="#cb5-19"></a>input_size_dict</span>
<span id="cb5-20"><a href="#cb5-20"></a><span class="co"># output</span></span>
<span id="cb5-21"><a href="#cb5-21"></a>{<span class="st">'y_hat'</span>: <span class="dv">40</span>,</span>
<span id="cb5-22"><a href="#cb5-22"></a> <span class="st">'c1'</span>: <span class="dv">20</span>,</span>
<span id="cb5-23"><a href="#cb5-23"></a> <span class="st">'c2'</span>: <span class="dv">20</span>,</span>
<span id="cb5-24"><a href="#cb5-24"></a> <span class="st">'b1'</span>: <span class="dv">32</span>,</span>
<span id="cb5-25"><a href="#cb5-25"></a> <span class="st">'b2'</span>: <span class="dv">8</span>,</span>
<span id="cb5-26"><a href="#cb5-26"></a> <span class="st">'a1_input'</span>: <span class="fl">0.0</span>,</span>
<span id="cb5-27"><a href="#cb5-27"></a> <span class="st">'a2_input'</span>: <span class="fl">0.0</span>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now we can update the graph from above adding in the input/output sizes.</p>
<p><img src="GraphWithUnits.png" class="img-fluid"></p>
</section>
<section id="how-to-move-through-the-graph" class="level2">
<h2 class="anchored" data-anchor-id="how-to-move-through-the-graph">3. How to move through the graph</h2>
<p>To calculate the prediction for an observation each node in the graph needs to be run after all it’s input nodes have been run. Specifically, I need a list of nodes, ordered such that each node comes after all the nodes on which it depends.</p>
<p>This takes little doing. Here I use some custom helper function to find the unique entries in a dictionary, the “top” nodes (those on which no other nodes depend).</p>
<div class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1"></a><span class="co"># start by finding the top level -- all those keys which are themselves not values</span></span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="co"># helper function to get all keys and all value from a dict. Useful for when keys don't have unique values.</span></span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="kw">def</span> find_uniq_keys_values(input_dict):</span>
<span id="cb6-4"><a href="#cb6-4"></a>    all_keys <span class="op">=</span> <span class="bu">list</span>(input_dict.keys())</span>
<span id="cb6-5"><a href="#cb6-5"></a>    all_values <span class="op">=</span> []</span>
<span id="cb6-6"><a href="#cb6-6"></a>    <span class="cf">for</span> e <span class="kw">in</span> all_keys:</span>
<span id="cb6-7"><a href="#cb6-7"></a>        all_values.extend(input_dict[e])</span>
<span id="cb6-8"><a href="#cb6-8"></a>    all_values <span class="op">=</span> <span class="bu">list</span>(<span class="bu">set</span>(all_values))</span>
<span id="cb6-9"><a href="#cb6-9"></a></span>
<span id="cb6-10"><a href="#cb6-10"></a>    <span class="cf">return</span>({<span class="st">'all_keys'</span>: all_keys,</span>
<span id="cb6-11"><a href="#cb6-11"></a>           <span class="st">'all_values'</span>: all_values})</span>
<span id="cb6-12"><a href="#cb6-12"></a></span>
<span id="cb6-13"><a href="#cb6-13"></a><span class="co"># find the dependencies for run order from many dependencies to none</span></span>
<span id="cb6-14"><a href="#cb6-14"></a><span class="co"># wrapper function to find the nodes that aren't any other nodes dependencies.</span></span>
<span id="cb6-15"><a href="#cb6-15"></a><span class="kw">def</span> find_top_nodes(all_key_value_dict):</span>
<span id="cb6-16"><a href="#cb6-16"></a>    <span class="cf">return</span>([e <span class="cf">for</span> e <span class="kw">in</span> all_key_value_dict[<span class="st">'all_keys'</span>] <span class="cf">if</span> e <span class="kw">not</span> <span class="kw">in</span> all_key_value_dict[<span class="st">'all_values'</span>]])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Similar to how I calculated each node’s output size, here I copy the connection dictionary and then manipulate it. I repeatedly identify the top-most nodes in the graph, add them to a list, and then <em>remove them</em> from the dictionary. Repeating this “peels” of the top layer over and over until there are nodes left. The resulting list is ordered from top most to most basal, so reversing it is all that need be done to get the order nodes should be run in.</p>
<div class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1"></a><span class="co"># find the dependencies for run order from many dependencies to none</span></span>
<span id="cb7-2"><a href="#cb7-2"></a>temp <span class="op">=</span> node_connections.copy()</span>
<span id="cb7-3"><a href="#cb7-3"></a></span>
<span id="cb7-4"><a href="#cb7-4"></a>dependancy_order <span class="op">=</span> []</span>
<span id="cb7-5"><a href="#cb7-5"></a><span class="co"># Then iterate</span></span>
<span id="cb7-6"><a href="#cb7-6"></a><span class="cf">for</span> ith <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">100</span>): </span>
<span id="cb7-7"><a href="#cb7-7"></a>    top_nodes <span class="op">=</span> find_top_nodes(all_key_value_dict <span class="op">=</span> find_uniq_keys_values(input_dict <span class="op">=</span> temp))</span>
<span id="cb7-8"><a href="#cb7-8"></a>    <span class="cf">if</span> top_nodes <span class="op">==</span> []:</span>
<span id="cb7-9"><a href="#cb7-9"></a>        <span class="cf">break</span></span>
<span id="cb7-10"><a href="#cb7-10"></a>    <span class="cf">else</span>:</span>
<span id="cb7-11"><a href="#cb7-11"></a>        dependancy_order <span class="op">+=</span> top_nodes    </span>
<span id="cb7-12"><a href="#cb7-12"></a>        <span class="co"># remove nodes from the graph that are at the 'top' level and haven't already been removed</span></span>
<span id="cb7-13"><a href="#cb7-13"></a>        <span class="cf">for</span> key <span class="kw">in</span> [e <span class="cf">for</span> e <span class="kw">in</span> dependancy_order <span class="cf">if</span> e <span class="kw">in</span> temp.keys()]:</span>
<span id="cb7-14"><a href="#cb7-14"></a>             temp.pop(key)</span>
<span id="cb7-15"><a href="#cb7-15"></a></span>
<span id="cb7-16"><a href="#cb7-16"></a>                </span>
<span id="cb7-17"><a href="#cb7-17"></a><span class="co"># reverse to get the order that the nodes should be called</span></span>
<span id="cb7-18"><a href="#cb7-18"></a>dependancy_order.reverse()                </span>
<span id="cb7-19"><a href="#cb7-19"></a>dependancy_order</span>
<span id="cb7-20"><a href="#cb7-20"></a><span class="co"># output</span></span>
<span id="cb7-21"><a href="#cb7-21"></a>[<span class="st">'a2_input'</span>, <span class="st">'a1_input'</span>, <span class="st">'b2'</span>, <span class="st">'b1'</span>, <span class="st">'c2'</span>, <span class="st">'c1'</span>, <span class="st">'y_hat'</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="turn-the-graph-into-a-neural-network" class="level2">
<h2 class="anchored" data-anchor-id="turn-the-graph-into-a-neural-network">4. Turn the graph into a neural network</h2>
<p>So far, we have the data in a useful format (<code>training_dataloader</code>), a description of what the network should look like (<code>node_connections</code>, <code>input_size_dict</code>, <code>output_size_dict</code>), and the order that nodes in the network should be run in (<code>dependancy_order</code>). With this, we can build the network. I’ll start by defining a node as a linear layer (<code>nn.Linear</code>) that is passed into a <code>ReLU</code>. By creating a function<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a> for making nodes, changing <em>every</em> node in the network is as easy as editing this function.</p>
<div class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1"></a><span class="kw">def</span> Linear_block(in_size, out_size, drop_pr):</span>
<span id="cb8-2"><a href="#cb8-2"></a>    block <span class="op">=</span> nn.Sequential(</span>
<span id="cb8-3"><a href="#cb8-3"></a>        nn.Linear(in_size, out_size),</span>
<span id="cb8-4"><a href="#cb8-4"></a>        nn.ReLU())</span>
<span id="cb8-5"><a href="#cb8-5"></a>    <span class="cf">return</span>(block)  </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now, I can go through each node in order of it’s dependencies and have it return the data (if it’s an input node), process inputs with a <code>Linear_block</code> (if it’s not an input node or the output node), or use a linear function to predict the trait<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a>.</p>
<div class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1"></a><span class="co"># fill in the list in dependency order. </span></span>
<span id="cb9-2"><a href="#cb9-2"></a>layer_list <span class="op">=</span> []</span>
<span id="cb9-3"><a href="#cb9-3"></a><span class="cf">for</span> key <span class="kw">in</span> dependancy_order:</span>
<span id="cb9-4"><a href="#cb9-4"></a>    <span class="cf">if</span> key <span class="kw">in</span> input_tensor_names:</span>
<span id="cb9-5"><a href="#cb9-5"></a>        layer_list <span class="op">+=</span> [</span>
<span id="cb9-6"><a href="#cb9-6"></a>            nn.Flatten()</span>
<span id="cb9-7"><a href="#cb9-7"></a>        ]</span>
<span id="cb9-8"><a href="#cb9-8"></a>    <span class="cf">elif</span> key <span class="op">!=</span> <span class="st">'y_hat'</span>:</span>
<span id="cb9-9"><a href="#cb9-9"></a>        layer_list <span class="op">+=</span> [</span>
<span id="cb9-10"><a href="#cb9-10"></a>            Linear_block(in_size<span class="op">=</span>example_dict_input_size[key], </span>
<span id="cb9-11"><a href="#cb9-11"></a>                         out_size<span class="op">=</span>example_dict_output_size[key])</span>
<span id="cb9-12"><a href="#cb9-12"></a>                      ]</span>
<span id="cb9-13"><a href="#cb9-13"></a>    <span class="cf">else</span>:</span>
<span id="cb9-14"><a href="#cb9-14"></a>        layer_list <span class="op">+=</span> [</span>
<span id="cb9-15"><a href="#cb9-15"></a>            nn.Linear(example_dict_input_size[key], </span>
<span id="cb9-16"><a href="#cb9-16"></a>                      example_dict_output_size[key])</span>
<span id="cb9-17"><a href="#cb9-17"></a>                      ]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="double-checking-the-model-structure" class="level2">
<h2 class="anchored" data-anchor-id="double-checking-the-model-structure">Double checking the model structure</h2>
<p>Using the lovely library <a href="https://github.com/szagoruyko/pytorchviz">torchviz</a>, we can visualize every computational step in this model.</p>
<p><img src="GraphTorchViz.png" class="img-fluid" width="340"></p>
<p>This is a lot to look at, but if we compare it to the earlier graph we can spot the same loop.</p>
<p><img src="CompareGraphs.png" class="img-fluid"></p>
</section>
<section id="the-moment-of-truth" class="level2">
<h2 class="anchored" data-anchor-id="the-moment-of-truth">The moment of truth…</h2>
<p>Now all that is left is to see if the model trains. Using the objects describing the graph, the names of the input tensors, and the order nodes should be run it I’ll initialze the network, train it for 200 epochs aaaaaannnnddd….</p>
<div class="cell" data-execution_count="16">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1"></a>model <span class="op">=</span> NeuralNetwork(example_dict <span class="op">=</span> node_connections, </span>
<span id="cb10-2"><a href="#cb10-2"></a>                      example_dict_input_size <span class="op">=</span> input_size_dict,</span>
<span id="cb10-3"><a href="#cb10-3"></a>                      example_dict_output_size <span class="op">=</span> output_size_dict,</span>
<span id="cb10-4"><a href="#cb10-4"></a>                      input_tensor_names <span class="op">=</span> <span class="bu">list</span>(input_tensor_dict.keys()),</span>
<span id="cb10-5"><a href="#cb10-5"></a>                      dependancy_order <span class="op">=</span> dependancy_order) </span>
<span id="cb10-6"><a href="#cb10-6"></a></span>
<span id="cb10-7"><a href="#cb10-7"></a></span>
<span id="cb10-8"><a href="#cb10-8"></a>model, loss_df <span class="op">=</span> train_nn_yx(</span>
<span id="cb10-9"><a href="#cb10-9"></a>    training_dataloader,</span>
<span id="cb10-10"><a href="#cb10-10"></a>    training_dataloader, <span class="co"># For demo, the training and testing data are the same.</span></span>
<span id="cb10-11"><a href="#cb10-11"></a>    model,</span>
<span id="cb10-12"><a href="#cb10-12"></a>    learning_rate <span class="op">=</span> <span class="fl">1e-3</span>,</span>
<span id="cb10-13"><a href="#cb10-13"></a>    batch_size <span class="op">=</span> <span class="dv">20</span>,</span>
<span id="cb10-14"><a href="#cb10-14"></a>    epochs <span class="op">=</span> <span class="dv">200</span></span>
<span id="cb10-15"><a href="#cb10-15"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>It works!</p>
<p><img src="TrainingHistory.png" class="img-fluid"></p>
<p>Now all that’s left is to scale it up to a full genome and all the connections between the genes in it 😅.</p>


</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>Have a look at the page source.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>This will not be a graph neural network, although they may be effective here.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>A box of numbers that can have multiple dimensions. A matrix is a “rank-2” tensor.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>Technically, with 4 possibilities you only need 3 binary digits where <code>[0, 0, 0]</code> would be 100% probability of the fourth nucleotide<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>I’m using a custom <code>Dataset</code> subclass. See source for details.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p>Technically a method since it’s in a class.<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7"><p>As an aside, the first time I wrote this I had all non-input nodes be Linear_blocks. This resulted in fair bit frusterated debugging as the network would either train perfectly or fail to train depending on how the last ReLU was initialized🤦🏼‍♂️.<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  let localAlternateSentinel = 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
      <div class="nav-footer-center"><a href="mailto:hello@danielkick.com">Contact Daniel</a></div>
    <div class="nav-footer-right"><a href="https://github.com/danielkick/danielkick.github.io">View the Source</a></div>
  </div>
</footer>



</body></html>