[
  {
    "objectID": "hype-doc.html",
    "href": "hype-doc.html",
    "title": "Hype Document 2023",
    "section": "",
    "text": "#Goals for this year\n#Reflections\n#Projects (contributions, components, instights) (impact)\n#Collaboration & mentorship\n#Design & documentation\n#Company building (things that help the company overall, not just your team/project) Recruiting, improving important processes\n#What you learned\n#Outside of work Blog postes, open source, talks/ panels"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "",
    "section": "",
    "text": "I am a PhD Biologist working as a research geneticist. Currently, my research focuses on using deep learning to predict maize yield from genetic, environmental, and management data using deep learning, machine learning, and statistical modeling. Previously, I focused on compensation of neural circuits to aberrant activity."
  },
  {
    "objectID": "projects.html",
    "href": "projects.html",
    "title": "Projects",
    "section": "",
    "text": "Writings\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWorse is better and not doing things “right”\n\n\n\ntacit knowledge\n\n\nbeginner\n\n\nintermediate\n\n\ncode\n\n\ndeep learning\n\n\n\n\n\n\n\nDaniel Kick\n\n\nOct 13, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nUse a spreadsheet to manage your CV & Resume\n\n\n\nprofessional development\n\n\nr\n\n\n\n\n\n\n\nDaniel Kick\n\n\nOct 3, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSimulation as a Super Power\n\n\n\ncode\n\n\nintermediate\n\n\nensembling\n\n\n\n\n\n\n\nDaniel Kick\n\n\nSep 21, 2023\n\n\n\n\n\n\n\n\n\n\n\n\nMaking a “Visible” Neural Network\n\n\n\ncode\n\n\nadvanced\n\n\n\n\n\n\n\nDaniel Kick\n\n\nSep 15, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSolving the Wrong Problem\n\n\n\ncode\n\n\ndebugging\n\n\ntacit knowledge\n\n\nintermediate\n\n\n\n\n\n\n\nDaniel Kick\n\n\nSep 15, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSave only what you need\n\n\n\ncode\n\n\ndebugging\n\n\ntacit knowledge\n\n\nbeginner\n\n\n\n\n\n\n\nDaniel Kick\n\n\nSep 13, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCapturing Tacit Knowledge Through Blogging\n\n\n\ntacit knowledge\n\n\nbeginner\n\n\n\n\n\n\n\nDaniel Kick\n\n\nSep 12, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTips: Do-nothing Scripting in Bash\n\n\n\ncode\n\n\nbash\n\n\nbeginner\n\n\ntips\n\n\n\n\n\n\n\nDaniel Kick\n\n\nMay 24, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTrivia: R can have Comments in Tables\n\n\n\ncode\n\n\nr\n\n\nintermediate\n\n\ntips\n\n\ntrivia\n\n\n\n\n\n\n\nDaniel Kick\n\n\nMay 23, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEnsemble of BLUP, Machine Learning, and Deep Learning Models Predict Maize Yield Better Than Each Model Alone\n\n\n\n\n\n\nDaniel Kick\n\n\nApr 2, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nYield prediction through integration of genetic, environment, and management data through deep learning\n\n\n\n\n\n\nDaniel Kick\n\n\nJan 10, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTips: Open a new Interactive Session in Running Session\n\n\n\ncode\n\n\nhpc\n\n\nintermediate\n\n\ntips\n\n\n\n\n\n\n\nDaniel Kick\n\n\nOct 27, 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTrivia: In Python Missing Isn’t Equal to Itself\n\n\n\ncode\n\n\npython\n\n\nbeginner\n\n\ntips\n\n\ntrivia\n\n\n\n\n\n\n\nDaniel Kick\n\n\nSep 28, 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTiming-Dependent Potentiation and Depression of Electrical Synapses Contribute to Network Stability in the Crustacean Cardiac Ganglion\n\n\n\n\n\n\nDaniel Kick\n\n\nAug 31, 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTips: Cache Intermediate Results with pickle\n\n\n\ncode\n\n\npython\n\n\nintermediate\n\n\ntips\n\n\n\n\n\n\n\nDaniel Kick\n\n\nMar 23, 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTips: For those coming from R: Silent In Place Replacement\n\n\n\ncode\n\n\npython\n\n\nr\n\n\nintermediate\n\n\ntips\n\n\n\n\n\n\n\nDaniel Kick\n\n\nFeb 16, 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTips: Reusing Custom Functions\n\n\n\ncode\n\n\npython\n\n\nintermediate\n\n\ntips\n\n\n\n\n\n\n\nDaniel Kick\n\n\nJul 13, 2021\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTips: More Readable Data with pretty-print\n\n\n\ncode\n\n\npython\n\n\nbeginner\n\n\ntips\n\n\n\n\n\n\n\nDaniel Kick\n\n\nJun 21, 2021\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTips: Find the Graph you want in using a Graph Gallery\n\n\n\ncode\n\n\npython\n\n\nbeginner\n\n\ntips\n\n\n\n\n\n\n\nDaniel Kick\n\n\nJun 15, 2021\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTips: Jupyter Plugins\n\n\n\ncode\n\n\npython\n\n\nbeginner\n\n\ntips\n\n\n\n\n\n\n\nDaniel Kick\n\n\nJun 9, 2021\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMolecular profiling of single neurons of known identity in two ganglia from the crab Cancer borealis\n\n\n\n\n\n\nDaniel Kick\n\n\nDec 5, 2019\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCell Communication: Studying gap junctions with PARIS\n\n\n\n\n\n\nDaniel Kick\n\n\nMar 1, 2019\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDopamine maintains network synchrony via direct modulation of gap junctions in the crustacean cardiac ganglion\n\n\n\n\n\n\nDaniel Kick\n\n\nOct 16, 2018\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMotor Systems: Variability in neural networks\n\n\n\n\n\n\nDaniel Kick\n\n\nJan 18, 2018\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe Hillary Climber trumps manual testing: an automatic system for studying Drosophila climbing\n\n\n\n\n\n\nDaniel Kick\n\n\nSep 16, 2016\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/manuscript-lane-et-al-2018/index.html",
    "href": "posts/manuscript-lane-et-al-2018/index.html",
    "title": "Dopamine maintains network synchrony via direct modulation of gap junctions in the crustacean cardiac ganglion",
    "section": "",
    "text": "https://elifesciences.org/articles/39368"
  },
  {
    "objectID": "posts/DanielKick/231003_profdev_r_for_cv/index.html",
    "href": "posts/DanielKick/231003_profdev_r_for_cv/index.html",
    "title": "Use a spreadsheet to manage your CV & Resume",
    "section": "",
    "text": "For the past year I’ve been using a spreadsheet and RStudio to manage my resume and curriculum vitae. This post is a pitch for why you might want to do this and an overview of the system. There will be a follow up post on how to get started if you decide to use his approach."
  },
  {
    "objectID": "posts/DanielKick/231003_profdev_r_for_cv/index.html#why-use-a-spreadsheet",
    "href": "posts/DanielKick/231003_profdev_r_for_cv/index.html#why-use-a-spreadsheet",
    "title": "Use a spreadsheet to manage your CV & Resume",
    "section": "Why use a spreadsheet?",
    "text": "Why use a spreadsheet?\nThe key reason why you should use a spreadsheet to manage your resume is that it enables easy filtering and sorting. In essence your spreadsheet becomes a personal work history database from which you can quickly retrieve entries relevant to the application at hand.\nIf instead all your experiences went into an all encompassing text document, tailoring a document to a position would require you to go through each section and cut out most of the entries. To be clear – there are far worse strategies out there. Having a single reference document keeps your information together and means that much of your formatting work is done ahead of time.\nThis is where RStudio comes in. Rmarkdown gives you a way to draw entries from your spreadsheet, filter them, and then turn those entries into beautifully formatted text. Not to mention that you can have R update text for you1."
  },
  {
    "objectID": "posts/DanielKick/231003_profdev_r_for_cv/index.html#overview",
    "href": "posts/DanielKick/231003_profdev_r_for_cv/index.html#overview",
    "title": "Use a spreadsheet to manage your CV & Resume",
    "section": "Overview",
    "text": "Overview\nLet’s see how this works. All the code and data for my resume and cv is on GitHub. Every time I update the spreadsheet or tweak the documents’ aesthetics I add a commit.\n\nUpdating the documents is a 4 step process that takes just a few moments. Earlier this month when a paper of mine was accepted. To update my documents I…\n\nedited the positions.csv document and added a row with the paper’s bibliographic information and url.\nopened my Rmarkdown files Curriculum-Vitae.Rmd and Resume.Rmd and knit them to pdfs.\ncopied the output pdfs to a second repository to share with others\ncommited and pushed these new documents to GitHub (and then did the same for the cv repository)\n\n\nYou might be wondering – what’s with the last two steps? Why move the documents and then push to GitHub instead of keeping them where they are? And why put these on GitHub in the first place?\nPutting these on GitHub (or online for that matter) makes it easy to go from your resume to your online presence (LinkedIn, Orcid, personal website, etc.) from links in your resume. This means that if you embed a link to your resume in your resume then every paper copy you hand out and every business card links to the most up to date version.\n\nUsing a second repository is just to have a cleaner presentation. Every file that isn’t your resume is a distraction – and if your recipient wants to see your GitHub they’ll be just one click away."
  },
  {
    "objectID": "posts/DanielKick/231003_profdev_r_for_cv/index.html#a-more-detailed-look",
    "href": "posts/DanielKick/231003_profdev_r_for_cv/index.html#a-more-detailed-look",
    "title": "Use a spreadsheet to manage your CV & Resume",
    "section": "A More Detailed Look:",
    "text": "A More Detailed Look:\nLet’s take a look at positions.csv.\nThe first column, section, is the categories in your document. Several categories might be presented together (e.g. national_presentations and regional_presentations) but they aren’t assumed to be. The next column, in_resume, is a simple filter. Everything goes into the curriculum vitae, not so with the resume. Next we have institution. This one is a little odd because it includes university or organization names but also lists of authors (e.g. row 44). This is because all the items in this column are formatted the same way. After showing the title of an entry, we want to show this information. Dates are included using the start and end columns and location information (here urls) in loc. Finally, are several description_ columns. Extra information you want can be added to these.\n\nWhen I updated this spreadsheet I already had an entry from when I submitted the paper and put it $bioR\\chiiv$.\n\nOnly three cells had to change, moving it from the in review section to the academic articles section, tweaking the title, and updating the url.\n\nIn RStudio, the CV is ready to go. All I had to do was click the Knit button and wait for the pdf.\nThe resume took ever so slightly more work. For space and aesthetic reasons I use a non-default formatting for my publications. This is a manual step but is not hard at all. All I did was:\n\nRead in the position data and run line 433 position_data %&gt;% print_section('academic_articles'). This produces markdown formatted text. Each line of text is treated as a separate “item” and will be formatted according to some rules.\nCopy the markdown formatted text for the new publication.\nPaste it into the document and tweak the formatting:\n\nUse a smaller font size for everything between &lt;font size=\"1\"&gt; and &lt;/font&gt; .\nBold my name using ***\n\nDisplay authors and link together as the second line and don’t apply the third line’s formatting rules to anything (N/A)\n\n\n\n\nWith those edits made I click the “Knit” button again et voilà! Resume updated and ready to go."
  },
  {
    "objectID": "posts/DanielKick/231003_profdev_r_for_cv/index.html#bonus-updating-values-in-the-text",
    "href": "posts/DanielKick/231003_profdev_r_for_cv/index.html#bonus-updating-values-in-the-text",
    "title": "Use a spreadsheet to manage your CV & Resume",
    "section": "Bonus: Updating values in the text",
    "text": "Bonus: Updating values in the text\nOne of the coolest tricks you can do if your resume is in R is to update text dynamically. You don’t have to search through and count how many students you’ve mentored, or papers you published2.\nHere’s a simple example. I want to include how long I’ve been using R, but I don’t want to have to update that by hand. You could calculate this in R like so:\n\ntoday     &lt;- as.Date(format(Sys.time(), \"%Y-%m-%d\")) # Get today's date\nstart_R   &lt;- as.Date(\"2017-01-29\")                   # Set starting date\ndays_diff &lt;- difftime(today, start_R)                # Calc. days elapsed\nyears     &lt;- as.numeric(days_diff) / 365             # Convert to years\nyears     &lt;- round(years)                            # Round\nyears\n\nRMarkdown let’s you embed this calculation in the text. In my documents I have something like this “R Programming (7years )” which will show up in the pdf as “R Programming (# years)”."
  },
  {
    "objectID": "posts/DanielKick/231003_profdev_r_for_cv/index.html#footnotes",
    "href": "posts/DanielKick/231003_profdev_r_for_cv/index.html#footnotes",
    "title": "Use a spreadsheet to manage your CV & Resume",
    "section": "Footnotes",
    "text": "Footnotes\n\nSee the bonus at the very end.↩︎\nLook at line 430 in Resume.Rmd↩︎"
  },
  {
    "objectID": "posts/DanielKick/230913_filtering_to_save_88pr_space/index.html",
    "href": "posts/DanielKick/230913_filtering_to_save_88pr_space/index.html",
    "title": "Save only what you need",
    "section": "",
    "text": "[1] 7424.908\n\n\n[1] 735.05"
  },
  {
    "objectID": "posts/DanielKick/230913_filtering_to_save_88pr_space/index.html#how-we-got-to-this-point",
    "href": "posts/DanielKick/230913_filtering_to_save_88pr_space/index.html#how-we-got-to-this-point",
    "title": "Save only what you need",
    "section": "How we got to this point:",
    "text": "How we got to this point:\nCollecting data from many sites is expensive but using a biophysical model, many sites and years can be ‘harvested’ in minutes. I’m building a dataset with many cultivars planted across the united states. The problem is that I’m being greedy – I want to have the a day by day account of plant’s growth at ~1,300 locations from 1984-2022, varying cultivar, and planting date.\nIn my initial implementation the results from the model are written to a csv for each location…\n\n\nOh no.\n\nThis file has a boat load of data. It’s a table of 25,243,175 rows by 19 columns – 479,620,325 billion cells. By the end of the experiment much of my hard drive will be taken up by these."
  },
  {
    "objectID": "posts/DanielKick/230913_filtering_to_save_88pr_space/index.html#reclaiming-88-storage-space",
    "href": "posts/DanielKick/230913_filtering_to_save_88pr_space/index.html#reclaiming-88-storage-space",
    "title": "Save only what you need",
    "section": "Reclaiming 88% Storage Space",
    "text": "Reclaiming 88% Storage Space\nAn easy place to cut cells is from redundant or unneeded columns. These are produced by the simulation but the way I have the experiment structured, they aren’t needed after it’s done running.\n# YAGNI isn't just for code\ndf &lt;- df[, c(\n      # Indepenent Variables\n      'ith_lon', 'ith_lat', 'soils_i', 'SowDate', 'Genotype', 'Date',\n      \n      # Dependent Variables\n      'Maize.AboveGround.Wt', 'Maize.LAI', 'yield_Kgha'\n\n      # Redundant or not needed\n      #'X', 'ith_year_start', 'ith_year_end', 'factorial_file', 'CheckpointID', \n      #'SimulationID', 'Experiment', 'FolderName', 'Zone', 'Clock.Today'\n      )]\nThis is an easy way to get rid of over half the cells (down to 47.36%) (and really I should not have saved these in the first place) but we can do better still.\nMany of the rows represent times before planting without any data collected. All rows where Maize.AboveGround.Wt, Maize.LAI, and Maize.AboveGround.Wt are 0 can be dropped. Because so much of the year is out of the growing season this is quite helpful and cuts about half of the observations (20.09%).\nSplitting these data into two tables with independent variables or dependent variables (with a key) gets the total down to 10,602 + 53,530,975 = 53,541,577. Still a lot but only 11.16% of the starting size!\n\n\n\n\n\nData\nSize\nPercent Original\n\n\n\nOriginal\n479620325\n100.00\n\n\nSelect Cols.\n227188575\n47.37\n\n\nFilter Rows\n96355755\n20.09\n\n\nSplit Tables\n53541577\n11.16\n\n\n\n\n\n\nI could probably go even further, but now that each experiment takes up only 482 MB instead of 4.64 GB. Furhter optimization can wait for another day.\nWhile storage space is important (at this scale), another factor for the performance (and quality of life) is reading in the data. Using the basic read.csv function it takes 4 minutes 23 seconds to read in. Using the vroom library instead can read in these data in only 4.04 seconds."
  },
  {
    "objectID": "posts/DanielKick/210609_python_jupyter_plugins/index.html",
    "href": "posts/DanielKick/210609_python_jupyter_plugins/index.html",
    "title": "Tips: Jupyter Plugins",
    "section": "",
    "text": "I came across a handy set of tools for jupyter. There are of extensions for the notebooks that give you access to code snips, autocomplete by default, rendering a notebook as a slide show, and other features. To get it installed within an anaconda virtual environment you may only need to install it with this command:\nconda install -c conda-forge jupyter_contrib_nbextensions\nI not all of the extensions were showing up for me until I also ran these two lines, so it may take a bit of fiddling to get it to run.\njupyter contrib nbextension install --user\njupyter nbextension enable codefolding/main\nHere’s a linkto a page that shows some of these extensions in action."
  },
  {
    "objectID": "posts/DanielKick/221027_hpc_access_running_session/index.html",
    "href": "posts/DanielKick/221027_hpc_access_running_session/index.html",
    "title": "Tips: Open a new Interactive Session in Running Session",
    "section": "",
    "text": "A handy trick with batched processes on an HPC is that you can start an interactive session in a running session. Here’s an example where I needed to check if I was nearing the maximum allowed memory:\nHere I list my active jobs to get the jobid, run bash on that node, and list the processes by memory usage.\n[daniel.kick@Atlas-login-1 BLUP_G]$ squeue -u daniel.kick\n             JOBID PARTITION     NAME     USER ST       TIME  NODES NODELIST(REASON)\n           2491772     atlas   BLUP-W daniel.k  R      39:56      1 Atlas-0025\n[daniel.kick@Atlas-login-1 BLUP_G]$ srun --pty --jobid 2491772 bash\n[daniel.kick@Atlas-0025 BLUP_G]$ htop"
  },
  {
    "objectID": "posts/DanielKick/index.html",
    "href": "posts/DanielKick/index.html",
    "title": "Writings",
    "section": "",
    "text": "Posts here written for at target audience of graduate students and undergraduates. Most are available on the lab protocol website of my postdoctoral lab.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWorse is better and not doing things “right”\n\n\n\ntacit knowledge\n\n\nbeginner\n\n\nintermediate\n\n\ncode\n\n\ndeep learning\n\n\n\n\n\n\n\nDaniel Kick\n\n\nOct 13, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nUse a spreadsheet to manage your CV & Resume\n\n\n\nprofessional development\n\n\nr\n\n\n\n\n\n\n\nDaniel Kick\n\n\nOct 3, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSimulation as a Super Power\n\n\n\ncode\n\n\nintermediate\n\n\nensembling\n\n\n\n\n\n\n\nDaniel Kick\n\n\nSep 21, 2023\n\n\n\n\n\n\n\n\n\n\n\n\nMaking a “Visible” Neural Network\n\n\n\ncode\n\n\nadvanced\n\n\n\n\n\n\n\nDaniel Kick\n\n\nSep 15, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSolving the Wrong Problem\n\n\n\ncode\n\n\ndebugging\n\n\ntacit knowledge\n\n\nintermediate\n\n\n\n\n\n\n\nDaniel Kick\n\n\nSep 15, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSave only what you need\n\n\n\ncode\n\n\ndebugging\n\n\ntacit knowledge\n\n\nbeginner\n\n\n\n\n\n\n\nDaniel Kick\n\n\nSep 13, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCapturing Tacit Knowledge Through Blogging\n\n\n\ntacit knowledge\n\n\nbeginner\n\n\n\n\n\n\n\nDaniel Kick\n\n\nSep 12, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTips: Do-nothing Scripting in Bash\n\n\n\ncode\n\n\nbash\n\n\nbeginner\n\n\ntips\n\n\n\n\n\n\n\nDaniel Kick\n\n\nMay 24, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTrivia: R can have Comments in Tables\n\n\n\ncode\n\n\nr\n\n\nintermediate\n\n\ntips\n\n\ntrivia\n\n\n\n\n\n\n\nDaniel Kick\n\n\nMay 23, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTips: Open a new Interactive Session in Running Session\n\n\n\ncode\n\n\nhpc\n\n\nintermediate\n\n\ntips\n\n\n\n\n\n\n\nDaniel Kick\n\n\nOct 27, 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTrivia: In Python Missing Isn’t Equal to Itself\n\n\n\ncode\n\n\npython\n\n\nbeginner\n\n\ntips\n\n\ntrivia\n\n\n\n\n\n\n\nDaniel Kick\n\n\nSep 28, 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTips: Cache Intermediate Results with pickle\n\n\n\ncode\n\n\npython\n\n\nintermediate\n\n\ntips\n\n\n\n\n\n\n\nDaniel Kick\n\n\nMar 23, 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTips: For those coming from R: Silent In Place Replacement\n\n\n\ncode\n\n\npython\n\n\nr\n\n\nintermediate\n\n\ntips\n\n\n\n\n\n\n\nDaniel Kick\n\n\nFeb 16, 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTips: Reusing Custom Functions\n\n\n\ncode\n\n\npython\n\n\nintermediate\n\n\ntips\n\n\n\n\n\n\n\nDaniel Kick\n\n\nJul 13, 2021\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTips: More Readable Data with pretty-print\n\n\n\ncode\n\n\npython\n\n\nbeginner\n\n\ntips\n\n\n\n\n\n\n\nDaniel Kick\n\n\nJun 21, 2021\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTips: Find the Graph you want in using a Graph Gallery\n\n\n\ncode\n\n\npython\n\n\nbeginner\n\n\ntips\n\n\n\n\n\n\n\nDaniel Kick\n\n\nJun 15, 2021\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTips: Jupyter Plugins\n\n\n\ncode\n\n\npython\n\n\nbeginner\n\n\ntips\n\n\n\n\n\n\n\nDaniel Kick\n\n\nJun 9, 2021\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/DanielKick/230524_linux_do_nothing_scripting/index.html",
    "href": "posts/DanielKick/230524_linux_do_nothing_scripting/index.html",
    "title": "Tips: Do-nothing Scripting in Bash",
    "section": "",
    "text": "Do-nothing scripting is a nice way to blend documenting a protocol with running it. You can use this template as a place to start:\n#!/usr/bin/bash\n#-----------------------------------------------------------------------------#\nSTEP='Step 0:'\necho \"$STEP\"\necho \"Run? (y/n)\"; read -n 1 k &lt;&1\nif [[ $k = n ]] ; then\nprintf \"\\nSkipping $STEP\\n\"; fi\nelse\nprintf \"\\nDoing $STEP\\n\"\n# Code for step here:\nNote, having the condition be on n instead of yes allows for the code (which will vary in length) to be at the end. This makes the control flow easy to see."
  },
  {
    "objectID": "posts/DanielKick/220323_python_caching_pickle/index.html",
    "href": "posts/DanielKick/220323_python_caching_pickle/index.html",
    "title": "Tips: Cache Intermediate Results with pickle",
    "section": "",
    "text": "Here’s a useful pattern I’ve been getting a lot of mileage out of lately. If you’re running an analysis that has a time consuming step you can save the result as a python readable “pickle” file. Addendum: In some cases pickling a python objects can sometimes succeed in storing and retrieving data where a library’s built in functions for saving/loading data fails.\nimport pickle as pkl\n\npath = \"./data_intermediates/processed_data.pkl\"\nif os.path.exists(path):\n    processed_data = pkl.load(open(path, 'rb'))\nelse:\n    # Make `processed_data` here\n    pkl.dump(processed_data, open(path, 'wb'))\nThis also lets you batch a process so that you can do more with your resources. For example here’s a list comprehension that will (for each day from 0-287) rearrange the weather data to be in “long” format. This is concise but requires processing the whole list at once which takes a lot of resources.\nsal_long_list = [_get_weather_long(results_list = res,\n                                   current_day = ith_day) for ith_day in np.linspace(start = 0, stop = 287, num = 288)]\nIf we incorporate it into the pattern above we can hold fewer items in memory at a time and then merge them (e.g. with list.extend() ) after the fact.\nfor ii in range(3):\n    file_path = '../data/result_intermediates/sal_df_W_long_part_day'+['0-95', \n                                                                       '96-191', \n                                                                       '192-287'][ii]+'.pkl'\n    if os.path.exists(file_path):\n        sal_long_list = pkl.load(open(file_path, 'rb'))\n\n    else:\n        # The original list comprehension is here, \n        # just made messier by selecting a subset of the indices.\n        sal_long_list = [_get_weather_long(                                \n            results_list = res,\n            current_day = current_day) for current_day in [\n            [int(e) for e in np.linspace(start = 0, stop = 95, num = 96)],   # Batch 1\n            [int(e) for e in np.linspace(start = 96, stop = 191, num = 96)], # Batch 2\n            [int(e) for e in np.linspace(start = 192, stop = 287, num = 96)] # Batch 3\n        ][ii]\n        ]\n        pkl.dump(sal_long_list, open(file_path, 'wb'))"
  },
  {
    "objectID": "posts/DanielKick/210713_python_custom_functions/index.html",
    "href": "posts/DanielKick/210713_python_custom_functions/index.html",
    "title": "Tips: Reusing Custom Functions",
    "section": "",
    "text": "Amendment: For packaging functions also see nbdev.\nI wanted to reuse a custom function across a few scripts without having copies of the same code in each script. The solution I found is to set up a module to hold these functions. This seems straightforward once you know how it’s done.\n\nSet up a directory containing your functions and a blank file called __init__.py.\n\nAdd the directory containing your module directory to the system path (here MaizeModel instead of MaizeModel\\\\library). If you’re on OSX or linux you’ll probably use single forward slashes instead of double backslashes.\n\nFinally import and call your functions.\n\nCaveats:\n\nIt seems that the system path isn’t permanently altered by sys.path.append, so one would need that at the start of the script or modify it some other way.\nIf your custom functions are in the in the same directory as your script, I think you can skip all of this and just import them.\nIf your functions are in a sub-directory of the same directory as your script, I think you can get away without adding the directory to the path."
  },
  {
    "objectID": "posts/DanielKick/230915_vnn_overview/index.html",
    "href": "posts/DanielKick/230915_vnn_overview/index.html",
    "title": "Making a “Visible” Neural Network",
    "section": "",
    "text": "In most neural networks, neurons are not parametric in the same way that linear models are. In a image recognition model there may be neuron which functions to detects edges but when the model is set up initially one can’t point to a neuron and say what it will do or represent. This can make interpreting the weights in a model tricky.\nVisible neural networks (VNN) are one way to get around this problem by making the structure of a model reflect the process being modeled. In a VNN, influential sub-components may be interpreted as implicating the process they represent as being important. Within biology VNNs have been used by Ma et al. 2018 and Hilten et al. 2021 working in yeast and humans respectively (in the later mixed performance, seemingly based on trait complexity)."
  },
  {
    "objectID": "posts/DanielKick/230915_vnn_overview/index.html#whats-a-visual-neural-network",
    "href": "posts/DanielKick/230915_vnn_overview/index.html#whats-a-visual-neural-network",
    "title": "Making a “Visible” Neural Network",
    "section": "",
    "text": "In most neural networks, neurons are not parametric in the same way that linear models are. In a image recognition model there may be neuron which functions to detects edges but when the model is set up initially one can’t point to a neuron and say what it will do or represent. This can make interpreting the weights in a model tricky.\nVisible neural networks (VNN) are one way to get around this problem by making the structure of a model reflect the process being modeled. In a VNN, influential sub-components may be interpreted as implicating the process they represent as being important. Within biology VNNs have been used by Ma et al. 2018 and Hilten et al. 2021 working in yeast and humans respectively (in the later mixed performance, seemingly based on trait complexity)."
  },
  {
    "objectID": "posts/DanielKick/230915_vnn_overview/index.html#a-hypothetical-gene-network",
    "href": "posts/DanielKick/230915_vnn_overview/index.html#a-hypothetical-gene-network",
    "title": "Making a “Visible” Neural Network",
    "section": "A hypothetical gene network",
    "text": "A hypothetical gene network\nBefore scaling to representing gene networks, I built a simple test case and will walk through it below, with all the necessary code (but some of it hidden1 for brevity).\n\nHere we have a hypothetical network which involves two genes (a1_input, a2_input), variants of which affect some initial processes (b1, b2), which in turn affect a second set of processes (c1, c2). I’ll use these last processes to predict my trait of interest (y_hat).\nThis is a directed acyclic graph, meaning that processes have an order (the arrows) and there are no loops (c1 doesn’t some how change a1_input). The model I’d like to end up with is a neural network with a structure that mirrors this graph 2 with each node representing one or more layers of neurons.\nBeginning with the end in mind, I need a way to specify: 1. The data the graph operates on 1. The process graph and each node’s attributes 1. How to “move” through the graph"
  },
  {
    "objectID": "posts/DanielKick/230915_vnn_overview/index.html#the-data-itself",
    "href": "posts/DanielKick/230915_vnn_overview/index.html#the-data-itself",
    "title": "Making a “Visible” Neural Network",
    "section": "1. The data itself",
    "text": "1. The data itself\nMy example trait, \\(y\\) is either 0 or 1 (plus a little noise). It’s controlled by two genes which are represented as tensor3 containing values for each possible nucleotide (ACGT) for each SNP measured in the gene. Conveniently, both genes either contain all 0’s or all 1’s and when there are only 0’s \\(y\\) will be around 0 (and the same for 1).\nThis of course means that in this population no nucleotides (all 0s) were observed or all nucleotides (all 1s) were simultaneously observed. Don’t ask me how this is possible 🤔. For real data these values would be probability of seeing a given nucelotide so “A” might be [1, 0, 0, 0]4.\n\nn_obs = 100 # 100 obs for each group\ny_true = torch.from_numpy(np.concatenate([\n        np.zeros((n_obs, )),\n        np.ones( (n_obs, ))], 0)) + .1* torch.rand(2*n_obs,)\n        \ninput_tensor_dict = {\n    'a1_input': torch.from_numpy(np.concatenate([\n        np.zeros((n_obs, 4, 3)),\n        np.ones( (n_obs, 4, 3))], 0)),\n    'a2_input': torch.from_numpy(np.concatenate([\n        np.zeros((n_obs, 4, 2)),  \n        np.ones( (n_obs, 4, 2))], 0))}\n\nx_list_temp = [input_tensor_dict[key].to(torch.float) for key in input_tensor_dict.keys()]\nx_list_temp\n# output\n                        # Probability of\n[tensor([[[0., 0., 0.], # A\n          [0., 0., 0.], # C\n          [0., 0., 0.], # G\n          [0., 0., 0.]],# T\n\n         ...,\n\n         [[1., 1., 1.],\n          [1., 1., 1.],\n          [1., 1., 1.],\n          [1., 1., 1.]]]),\n\n tensor([[[0., 0.],\n          [0., 0.],\n          [0., 0.],\n          [0., 0.]],\n\n         ...,\n\n         [[1., 1.],\n          [1., 1.],\n          [1., 1.],\n          [1., 1.]]])]\n\nThen this data can be packaged nicely in a DataLoader5. This will retrieve the trait (y) and SNPs for each gene (in x_list) for 20 observations at a time.\n\ntraining_dataloader = DataLoader(\n  ListDataset(\n    y = y_true[:, None].to(torch.float32), # Set as 32 bit float to match network\n    x_list = [e.to(torch.float32) for e in x_list_temp]),\n    batch_size = 20,\n    shuffle = True)"
  },
  {
    "objectID": "posts/DanielKick/230915_vnn_overview/index.html#defining-the-graph",
    "href": "posts/DanielKick/230915_vnn_overview/index.html#defining-the-graph",
    "title": "Making a “Visible” Neural Network",
    "section": "2. Defining the graph",
    "text": "2. Defining the graph\nThe structure of a graph can be nicely represented as a python dictionary so I’ll begin with that:\n\nnode_connections = {\n  'y_hat':['c1', 'c2'],\n  'c1':['b1'],\n  'c2':['b2'],\n  'b1':['a1_input', 'b2'],\n  'b2':['a2_input'],\n  'a1_input': [],\n  'a2_input': []\n}\n\nEach node will have an input and output size stored in a dictionary. The output sizes are easy, all nodes will have the same size except for the last node, which has predicts y, which will have a size of 1.\n\nnode_list = list(node_connections.keys())\n\ndefault_output_size = 20\noutput_size_dict = dict(zip(node_list, \n                        [default_output_size for i in range(len(node_list))]))\noutput_size_dict['y_hat'] = 1 \noutput_size_dict\n# output\n{'a1_input': 20,\n 'a2_input': 20,\n 'b1': 20,\n 'b2': 20,\n 'c1': 20,\n 'c2': 20,\n 'y_hat': 1}\n\nThe input sizes are a little trickier. A node’s input should be the number of SNPs in a gene (if it’s an input node) or the sum of the outputs of the nodes on which it depends (e.g. y_hat’s input size is the sum of c1 and c2’s outputs). To do this, I’m going to copy the dictionary with all the connections between nodes, then swap the node names for their output sizes. Summing the list of these output values will be the required input size. Data nodes don’t depend on input from other nodes, so those will have an input shape of 0.\n\ninput_size_dict = node_connections.copy()\n\nno_dependants = [e for e in node_connections.keys() if node_connections[e] == []]\n\n# use the expected output sizes from `output_size_dict` to fill in the non-data sizes\ntensor_ndim = len(input_tensor_dict[list(input_tensor_dict.keys())[0]].shape)\nfor e in tqdm(input_size_dict.keys()):\n    # overwrite named connections with the output size of those connections\n    # if the entry is in no_dependants it's data so it's size needs to be grabbed from the input_tensor_dict\n    input_size_dict[e] = [\n        (list(input_tensor_dict[ee].shape)[1]*list(input_tensor_dict[ee].shape)[2]) \n        if ee in no_dependants\n        else output_size_dict[ee] for ee in input_size_dict[e]]\n\n# Now walk over entries and overwrite with the sum of the inputs\nfor e in tqdm(input_size_dict.keys()):\n    input_size_dict[e] = np.sum(input_size_dict[e])\n    \ninput_size_dict\n# output\n{'y_hat': 40,\n 'c1': 20,\n 'c2': 20,\n 'b1': 32,\n 'b2': 8,\n 'a1_input': 0.0,\n 'a2_input': 0.0}\n\nNow we can update the graph from above adding in the input/output sizes."
  },
  {
    "objectID": "posts/DanielKick/230915_vnn_overview/index.html#how-to-move-through-the-graph",
    "href": "posts/DanielKick/230915_vnn_overview/index.html#how-to-move-through-the-graph",
    "title": "Making a “Visible” Neural Network",
    "section": "3. How to move through the graph",
    "text": "3. How to move through the graph\nTo calculate the prediction for an observation each node in the graph needs to be run after all it’s input nodes have been run. Specifically, I need a list of nodes, ordered such that each node comes after all the nodes on which it depends.\nThis takes little doing. Here I use some custom helper function to find the unique entries in a dictionary, the “top” nodes (those on which no other nodes depend).\n\n# start by finding the top level -- all those keys which are themselves not values\n# helper function to get all keys and all value from a dict. Useful for when keys don't have unique values.\ndef find_uniq_keys_values(input_dict):\n    all_keys = list(input_dict.keys())\n    all_values = []\n    for e in all_keys:\n        all_values.extend(input_dict[e])\n    all_values = list(set(all_values))\n\n    return({'all_keys': all_keys,\n           'all_values': all_values})\n\n# find the dependencies for run order from many dependencies to none\n# wrapper function to find the nodes that aren't any other nodes dependencies.\ndef find_top_nodes(all_key_value_dict):\n    return([e for e in all_key_value_dict['all_keys'] if e not in all_key_value_dict['all_values']])\n\nSimilar to how I calculated each node’s output size, here I copy the connection dictionary and then manipulate it. I repeatedly identify the top-most nodes in the graph, add them to a list, and then remove them from the dictionary. Repeating this “peels” of the top layer over and over until there are nodes left. The resulting list is ordered from top most to most basal, so reversing it is all that need be done to get the order nodes should be run in.\n\n# find the dependencies for run order from many dependencies to none\ntemp = node_connections.copy()\n\ndependancy_order = []\n# Then iterate\nfor ith in range(100): \n    top_nodes = find_top_nodes(all_key_value_dict = find_uniq_keys_values(input_dict = temp))\n    if top_nodes == []:\n        break\n    else:\n        dependancy_order += top_nodes    \n        # remove nodes from the graph that are at the 'top' level and haven't already been removed\n        for key in [e for e in dependancy_order if e in temp.keys()]:\n             temp.pop(key)\n\n                \n# reverse to get the order that the nodes should be called\ndependancy_order.reverse()                \ndependancy_order\n# output\n['a2_input', 'a1_input', 'b2', 'b1', 'c2', 'c1', 'y_hat']"
  },
  {
    "objectID": "posts/DanielKick/230915_vnn_overview/index.html#turn-the-graph-into-a-neural-network",
    "href": "posts/DanielKick/230915_vnn_overview/index.html#turn-the-graph-into-a-neural-network",
    "title": "Making a “Visible” Neural Network",
    "section": "4. Turn the graph into a neural network",
    "text": "4. Turn the graph into a neural network\nSo far, we have the data in a useful format (training_dataloader), a description of what the network should look like (node_connections, input_size_dict, output_size_dict), and the order that nodes in the network should be run in (dependancy_order). With this, we can build the network. I’ll start by defining a node as a linear layer (nn.Linear) that is passed into a ReLU. By creating a function6 for making nodes, changing every node in the network is as easy as editing this function.\n\ndef Linear_block(in_size, out_size, drop_pr):\n    block = nn.Sequential(\n        nn.Linear(in_size, out_size),\n        nn.ReLU())\n    return(block)  \n\nNow, I can go through each node in order of it’s dependencies and have it return the data (if it’s an input node), process inputs with a Linear_block (if it’s not an input node or the output node), or use a linear function to predict the trait7.\n\n# fill in the list in dependency order. \nlayer_list = []\nfor key in dependancy_order:\n    if key in input_tensor_names:\n        layer_list += [\n            nn.Flatten()\n        ]\n    elif key != 'y_hat':\n        layer_list += [\n            Linear_block(in_size=example_dict_input_size[key], \n                         out_size=example_dict_output_size[key])\n                      ]\n    else:\n        layer_list += [\n            nn.Linear(example_dict_input_size[key], \n                      example_dict_output_size[key])\n                      ]"
  },
  {
    "objectID": "posts/DanielKick/230915_vnn_overview/index.html#double-checking-the-model-structure",
    "href": "posts/DanielKick/230915_vnn_overview/index.html#double-checking-the-model-structure",
    "title": "Making a “Visible” Neural Network",
    "section": "Double checking the model structure",
    "text": "Double checking the model structure\nUsing the lovely library torchviz, we can visualize every computational step in this model.\n\nThis is a lot to look at, but if we compare it to the earlier graph we can spot the same loop."
  },
  {
    "objectID": "posts/DanielKick/230915_vnn_overview/index.html#the-moment-of-truth",
    "href": "posts/DanielKick/230915_vnn_overview/index.html#the-moment-of-truth",
    "title": "Making a “Visible” Neural Network",
    "section": "The moment of truth…",
    "text": "The moment of truth…\nNow all that is left is to see if the model trains. Using the objects describing the graph, the names of the input tensors, and the order nodes should be run it I’ll initialze the network, train it for 200 epochs aaaaaannnnddd….\n\nmodel = NeuralNetwork(example_dict = node_connections, \n                      example_dict_input_size = input_size_dict,\n                      example_dict_output_size = output_size_dict,\n                      input_tensor_names = list(input_tensor_dict.keys()),\n                      dependancy_order = dependancy_order) \n\n\nmodel, loss_df = train_nn_yx(\n    training_dataloader,\n    training_dataloader, # For demo, the training and testing data are the same.\n    model,\n    learning_rate = 1e-3,\n    batch_size = 20,\n    epochs = 200\n)\n\nIt works!\n\nNow all that’s left is to scale it up to a full genome and all the connections between the genes in it 😅."
  },
  {
    "objectID": "posts/DanielKick/230915_vnn_overview/index.html#footnotes",
    "href": "posts/DanielKick/230915_vnn_overview/index.html#footnotes",
    "title": "Making a “Visible” Neural Network",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nHave a look at the page source.↩︎\nThis will not be a graph neural network, although they may be effective here.↩︎\nA box of numbers that can have multiple dimensions. A matrix is a “rank-2” tensor.↩︎\nTechnically, with 4 possibilities you only need 3 binary digits where [0, 0, 0] would be 100% probability of the fourth nucleotide↩︎\nI’m using a custom Dataset subclass. See source for details.↩︎\nTechnically a method since it’s in a class.↩︎\nAs an aside, the first time I wrote this I had all non-input nodes be Linear_blocks. This resulted in fair bit frusterated debugging as the network would either train perfectly or fail to train depending on how the last ReLU was initialized🤦🏼‍♂️.↩︎"
  },
  {
    "objectID": "posts/manuscript-kick-and-schulz-2019/index.html",
    "href": "posts/manuscript-kick-and-schulz-2019/index.html",
    "title": "Cell Communication: Studying gap junctions with PARIS",
    "section": "",
    "text": "https://elifesciences.org/articles/45207"
  },
  {
    "objectID": "posts/manuscript-northcutt-kick-et-al-2019/index.html",
    "href": "posts/manuscript-northcutt-kick-et-al-2019/index.html",
    "title": "Molecular profiling of single neurons of known identity in two ganglia from the crab Cancer borealis",
    "section": "",
    "text": "https://www.pnas.org/doi/abs/10.1073/pnas.1911413116"
  },
  {
    "objectID": "posts/manuscript-kick-and-schulz-2022/index.html",
    "href": "posts/manuscript-kick-and-schulz-2022/index.html",
    "title": "Timing-Dependent Potentiation and Depression of Electrical Synapses Contribute to Network Stability in the Crustacean Cardiac Ganglion",
    "section": "",
    "text": "https://www.jneurosci.org/content/42/35/6751"
  },
  {
    "objectID": "resume.html",
    "href": "resume.html",
    "title": "Resume",
    "section": "",
    "text": "If no file appears, please follow this link to GitHub."
  },
  {
    "objectID": "notes.html",
    "href": "notes.html",
    "title": "notes",
    "section": "",
    "text": "\\(\\color{red}{\\text{TODO:}}\\) Add the following to `_quarto.yml`\n\nRe-list Projects\n\n\nRestore search\nMaybe restore title\n\n\n# website:\n#   title: \"Portfolio\"\n#   \n#   search: \n#     location: navbar\n#     type: overlay\n#   navbar:\n#     left: \n#       - text: Home\n#         href: index.qmd\n#       - text: Projects\n#         href: projects.qmd\n#     right:\n#       - text: Resume\n#         href: resume.qmd\n#       - text: CV\n#         href: curriculum-vitae.qmd\n#       - icon: github\n#         href: https://github.com/danielkick\n#       - icon: linkedin\n#         href: https://www.linkedin.com/in/daniel-kick-5a449b9a/\n\nDirectly usable icons can be found at:\nhttps://icons.getbootstrap.com/\nIf you use gifs gzip to decrease size to prevent the website from becoming sluggish\ncode highlighting can be found at https://quarto.org/docs/output-formats/html-code.html#highlighting"
  },
  {
    "objectID": "posts/manuscript-kick-and-washburn-2023/index.html",
    "href": "posts/manuscript-kick-and-washburn-2023/index.html",
    "title": "Ensemble of BLUP, Machine Learning, and Deep Learning Models Predict Maize Yield Better Than Each Model Alone",
    "section": "",
    "text": "https://www.biorxiv.org/content/10.1101/2023.03.30.532932v1"
  },
  {
    "objectID": "posts/manuscript-willenbrink-et-al-2016/index.html",
    "href": "posts/manuscript-willenbrink-et-al-2016/index.html",
    "title": "The Hillary Climber trumps manual testing: an automatic system for studying Drosophila climbing",
    "section": "",
    "text": "https://www.tandfonline.com/doi/abs/10.1080/01677063.2016.1255211"
  },
  {
    "objectID": "posts/manuscript-kick-et-al-2023/index.html",
    "href": "posts/manuscript-kick-et-al-2023/index.html",
    "title": "Yield prediction through integration of genetic, environment, and management data through deep learning",
    "section": "",
    "text": "https://academic.oup.com/g3journal/article/13/4/jkad006/6982634"
  },
  {
    "objectID": "posts/DanielKick/220216_python_silent_replace/index.html",
    "href": "posts/DanielKick/220216_python_silent_replace/index.html",
    "title": "Tips: For those coming from R: Silent In Place Replacement",
    "section": "",
    "text": "Silent, in place assignment updating an object This tripped me up even though it’s consistent with how I’ve seen other objects behave. I needed an attribute to hold data extracted from a collection of files in a directory and created a class for this.\nclass hps_search_experiment:\n    def __init__(self, path=\"\", trial_type=''):\n        self.path = path\n        self.trial_type = trial_type\n        self.hps_best_trial = None\n        \n    def process_hps_files(self):\n        # ...\n        \n        self.hps_best_trial = hps_best_trial\nHowever, running like so fails.\ntest = hps_search_experiment(\n    path = './hps_search_intermediates_G/', \n    trial_type = 'rnr')\n    \ntest = test.process_hps_files()\ntest.hps_best_trial\n\n#&gt; AttributeError: 'NoneType' object has no attribute 'hps_best_trial'\nThis had me baffeld because I was thinking with R’s norms of data &lt;- data %&gt;% funciton() where in place replacement is the exception. Instead I needed to be thinking with python’s base object norms (e.g. a_list.extend(['b', 'c']) ). This fails because I overwrote test with the output of the method, which returns notthing since it’s overwriting attributes within test’s scope.\nThese would also work to update the attribute:\nself.hps_best_trial = hps_best_trial\n\nhps_search_experiment.__setattr__(self, \"hps_best_trial\", hps_best_trial)\n\n# if it's initialized as a list\nself.hps_best_trial.append([hps_best_trial]) \n# if a dict is initialized for data\nself.data = {'a':1}\nself.data.update({'hps_best_trial':hps_best_trial})"
  },
  {
    "objectID": "posts/DanielKick/230915_solving_the_wrong_problem/index.html",
    "href": "posts/DanielKick/230915_solving_the_wrong_problem/index.html",
    "title": "Solving the Wrong Problem",
    "section": "",
    "text": "There’s a perspective that “it is better to know nothing than to know what ain’t so.”1 In my experience this is certainly the case with debugging because “knowing” will lead you down a rabbit trail of trying to solve the wrong problem.\nThe approach that works well for me is to “trust but verify” your knowledge. If your initial attempts to fix the bug in your code don’t work, take some time to check your assumptions – specifically your assumptions about where the bug is. This slows down your work initially because you’re often testing things that are behaving as you expect expectations, but this saves you from spending a lot of time trying to fix the wrong problems."
  },
  {
    "objectID": "posts/DanielKick/230915_solving_the_wrong_problem/index.html#what-you-know-that-aint-so",
    "href": "posts/DanielKick/230915_solving_the_wrong_problem/index.html#what-you-know-that-aint-so",
    "title": "Solving the Wrong Problem",
    "section": "",
    "text": "There’s a perspective that “it is better to know nothing than to know what ain’t so.”1 In my experience this is certainly the case with debugging because “knowing” will lead you down a rabbit trail of trying to solve the wrong problem.\nThe approach that works well for me is to “trust but verify” your knowledge. If your initial attempts to fix the bug in your code don’t work, take some time to check your assumptions – specifically your assumptions about where the bug is. This slows down your work initially because you’re often testing things that are behaving as you expect expectations, but this saves you from spending a lot of time trying to fix the wrong problems."
  },
  {
    "objectID": "posts/DanielKick/230915_solving_the_wrong_problem/index.html#a-recent-example",
    "href": "posts/DanielKick/230915_solving_the_wrong_problem/index.html#a-recent-example",
    "title": "Solving the Wrong Problem",
    "section": "A recent example:",
    "text": "A recent example:\nI’m writing a model that uses relationships between genes to predict a trait. The problem is that the model isn’t something I can write by hand (there are 6,067 inputs) and is way to slow – I’ve estimated it would take about 1.7 days to complete a single epoch (training cycle).\n\n\n\nHere are all the model’s processes for just two input genes.\n\n\nIn the diagram above, data from each gene (the nodes at the top) is fed into different functions (nodes 0-23) representing associations between different biological processes until they reach the output node (24) which predicts the trait.\nSome nodes share the same input (here node 14 and 10 both need node 11 as input). Under the hood I have the model storing the output of these nodes so it doesn’t have to re-calculate outputs un-necessarily (here the model would look-up the output of node 11 instead of recalculating it). This seems to work nicely but is a little unusual – in over two years this is the first time I’ve manually done this sort of thing.\nBecause of that, when I move my model from a tiny demo data set to the real thing and saw it was slow as molasses I “knew” my model slow because it was storing and retrieving intermediate results.\nOne assumption underlying this is that the model library is effectively designed and optimized such that it’s easier to get worse performance by doing unconventional things than better performance. This isn’t a bad assumption most of the time but we’ll see how it got me thinking about the wrong problem. My thought process went something like this:\n“Okay, so I’m doing something a little unconventional by looking up module outputs. Maybe if I can rewrite the model without this, some ☆Pytorch magic☆ will happen improving training speed.”\n“Hmm, the most straightforward way to write a model would be to chain the inputs and outputs like so”\ninput_1 = x_list[0]\nmodule_2 = x_list[1]\nintermediate_1 = module_1(input_1)\nintermediate_2 = module_2(input_2)\noutput  = module_3(nn.Concatenate([intermediate_1, intermediate_2], axis = 1))\n“But it would be unfeasible to do this because I’d have to write a line for each input and process 8,868 in total… or would it?”\nThis should have seemed like a totally unreasonable thing to do and been where I stopped to think if there was another way to get a speed increase (or tested this by writing a tiny neural net by hand with and without caching results and looked for a tiny difference in speed). However, years ago I met a class deadline by using python2 to write python2 code so this seemed perfectly feasible.\nSo the plan became :\n\nGenerate a boat load strings containing python code\nUse Python’s exec() and eval() functions to run each string\nSit back and think about what a clever idea it was having my code write my code.\n\nSeveral hours later I’ve learned a fair bit about how exec() and eval() handle scope and that their behavior between python2 and python3 has changed and still have no working model. So I decide to print the code I wanted executed to the console paste it (all 8,868 lines of it) into my model definition, and run it.\nThis solution was inelegant but quick to implement and exactly what needed to happen because the model didn’t perform any better. If anything it was slower, so there definitely wasn’t any ☆Pytorch magic☆ happening. This was a big enough surprise that it got me to question if the model was the problem after all instead of running down other rabbit trails."
  },
  {
    "objectID": "posts/DanielKick/230915_solving_the_wrong_problem/index.html#so-wheres-the-problem",
    "href": "posts/DanielKick/230915_solving_the_wrong_problem/index.html#so-wheres-the-problem",
    "title": "Solving the Wrong Problem",
    "section": "So where’s the problem?",
    "text": "So where’s the problem?\nBuilding a model may be the most evocative part of the data science workflow, but the steps that precede it are often as or more important. Choices around how to handle missing or potentially unrepresentative data are important as are how data is stored and moved around. In this case, I wasn’t thinking about these critical choices.\nFor each individual, there are data for genes throughout its genome (x_list, a list where each entry is a gene’s SNPs), and it’s trait of interest (y). Here’s the (simplified) code for this data set:\nclass ListDataset(Dataset):\n    def __init__(self, y, x_list):\n        self.y = y \n        self.x_list = x_list\n        \n    def __len__(self):\n        return len(self.y)\n    \n    def __getitem__(self, idx):\n        # Get the data for index `idx`\n        y_idx =self.y[idx]\n        x_idx =[x[idx, ] for x in self.x_list]\n        \n        # Move to GPU so model can access it\n        y_idx.to('cuda')\n        x_idx = [x.to('cuda') for x in x_idx]\n        return y_idx, x_idx\nDo you spot what’s happening? When __getitem__ loads an observation, it has to move data from each gene to the GPU. This process isn’t instantaneous and is happening for each of the 6,067 genes every time an observation is loaded.\nTraining a network with a mere 100 observations (batch size of 10) takes 101.89s/it but if all the data is moved to the GPU before its 15% faster at 86.34s/it.\nThat’s nice, but since there are over 80,000 observations, it’s not enough to make training this model feasible. There’s another place we can look for improvements, and that’s the batch size. Increasing the batch size will mean that more observations are being moved to the GPU at a time so it has to happen fewer times. In this example getting all training observations in a single batch makes training 86% faster at 13.44s/it."
  },
  {
    "objectID": "posts/DanielKick/230915_solving_the_wrong_problem/index.html#take-home",
    "href": "posts/DanielKick/230915_solving_the_wrong_problem/index.html#take-home",
    "title": "Solving the Wrong Problem",
    "section": "Take home:",
    "text": "Take home:\nTesting your assumptions (especially while debugging) is like insurance. When you’re on the right track from the start, it’ll cost you a little time that you otherwise wouldn’t have spent but it’ll keep you from spending a lot of time trying to solve the wrong problem.\npost script:\nEven solving the right problem the result may not be what you want. Extrapolating from a more realistic subset of the data results in an estimated 5.6 hours per epoch. Better than 1.7 days, but not a home run ."
  },
  {
    "objectID": "posts/DanielKick/230607_simulating_ensembles/index.html",
    "href": "posts/DanielKick/230607_simulating_ensembles/index.html",
    "title": "Simulation as a Super Power",
    "section": "",
    "text": "Writing simulations is one of the best ways I’m aware of to build one’s statistical intuition and comfort with data visualization. In addition to being able to try out new statistical tests and know exactly what effects they should find, they’re also great for communicating ideas and persuading others.\nA few months ago I had occasion to do just that.\n\\[...\\]\nAt the time I was advocating in a manuscript that when one needs to make a prediction combining predictions from different models is the way to go. Specifically, my results suggest that using a weighted average to make accurate models more influential. To do this, the predictions from each model are multiplied by the inverse of the model’s root mean squared error (rmse) of the model and summed. Someone helping me improve this manuscript thought that instead I should be weighting by the inverse of the model’s variance. This is a reasonable expectation (variance weighting is beautifully explained here) so I needed to convince my collaborator before the manuscript was ready for the world – Here’s how I did this with in a simulation that was only about 100 lines1 of R code."
  },
  {
    "objectID": "posts/DanielKick/230607_simulating_ensembles/index.html#simulating-observations",
    "href": "posts/DanielKick/230607_simulating_ensembles/index.html#simulating-observations",
    "title": "Simulation as a Super Power",
    "section": "Simulating Observations",
    "text": "Simulating Observations\nLet’s imagine we’re studying dead simple system where the output is equal to the input (\\(y = 0 + 1*x\\)). We can simulate as many samples as we would like from this system over a range of xs.\n\nn = 100 # samples to be generated\nxs &lt;- seq(0, 20, length.out = n) # x values evenly spaced from 0-20 \nys &lt;- 0+1*xs\n\nHere’s the simulated “data”.\n\n\n\n\n\n\n\n\nNow we can simulate models that are trying to predict y. To do this we’ll think of a model as being equivalent to the true value of y plus some model specific error. If we assume that the models aren’t prone to systematically over or underestimating, then we can use a normal distribution to generate these errors like so:\n\nmean1 =  0 # error doesn't tend to be over or under\nvar1  =  1 # variance of the error\ny1 &lt;- ys + rnorm(n = n, mean = mean1, sd = sqrt(var1))\n\nWe can simulate a better model by decreasing the variance (errors are consistently closer to the mean of 0). Conversely we can simulate a worse model by making the model tend to over or undershoot by changing the mean or make larger errors more common by increasing the varience. Here’s a model that’s worse than the previous one.\n\nmean2 =  1 # predictions tend to overshoot\nvar2  = 10 # larger errors are more common\ny2 &lt;- ys + rnorm(n = n, mean = mean2, sd = sqrt(var2))\n\nLet’s look at the predictions from model y1 and model y.\n\n\n\n\n\n\n\n\nHere we can see that y1’s error (vertical lines) are considerably smaller than that of y2.\nWe can subtract the true value \\(y\\) from the predicted value \\(\\hat y\\) to see this more clearly.\n\n\n\n\n\n\n\n\nIn panel B we can see the difference between the two error distributions for the models (save a few irregularities in these distributions from only using 100 samples.\nNow we can try out different averaging schemes to cancel out some of the error and get a better prediction. We can test a simple average like so.\n\ne1 &lt;- 0.5*y1 + 0.5*y2\n\nWe can also try placing more weight on models with less variable predictions (and hopefully smaller errors).\n\nyhat_vars  &lt;- unlist(map(list(y1, y2), function(e){var(e)})) # Calculate variance for each model's predictions\nwght_vars  &lt;- (1/yhat_vars)/sum(1/yhat_vars) # Take the inverse and get percent weight by dividing by the sum \ne2 &lt;- wght_vars[1]*y1  + wght_vars[2]*y2 # Scale each model's prediction and add to get the weighted average.\n\nWe can also try placing more weigh on models that are more accurate2.\n\nyhat_rmses &lt;- unlist(map(list(y1, y2), function(e){sqrt((sum((ys-e)**2)/n))}))\nwght_rmses &lt;- (1/yhat_rmses)/sum(1/yhat_rmses)\ne3 &lt;- wght_rmses[1]*y1 + wght_rmses[2]*y2\n\nNow we can calculate the RMSE for both models and these weighed averages.\n\n\n\n\n\nname\ny_rmse\nmean1\nmean2\nvar1\nvar2\n\n\n\ny1\n1.023765\n0\n1\n1\n10\n\n\ny2\n3.218318\n0\n1\n1\n10\n\n\nunif\n1.796390\n0\n1\n1\n10\n\n\nvar\n1.670037\n0\n1\n1\n10\n\n\nrmse\n1.217204\n0\n1\n1\n10\n\n\n\n\n\n\ny1 is the best set of predictions, averaging did not benefit predicitons here. This is not too much of a shock since y2 was generated by a model that was prone to systematically overshooting the true value and was more likely to have bigger errors.\nBut how would these results change if the models were more similar? What if the models had more similar error variences? Or if one was prone to overshooting while the other was prone to undershooting?"
  },
  {
    "objectID": "posts/DanielKick/230607_simulating_ensembles/index.html#expanding-the-simulation",
    "href": "posts/DanielKick/230607_simulating_ensembles/index.html#expanding-the-simulation",
    "title": "Simulation as a Super Power",
    "section": "Expanding the Simulation",
    "text": "Expanding the Simulation\nTo answer this we can package all the code above into a function with variables for each models’ error distribution and how many observations to simulate and return the RMSE for each model. This function (run_sim) is a little lengthy so I’ve collapsed it here:\n\nCoderun_sim &lt;- function(\n    n = 10000,\n    mean1 = 0,\n    mean2 = 1, \n    var1 = 1,\n    var2 = 10\n  ){\n  xs &lt;- seq(0, 20, length.out = n)\n  ys &lt;- 0+1*xs\n\n  # Simulate models\n  y1 &lt;- ys + rnorm(n = n, mean = mean1, sd = sqrt(var1))\n  y2 &lt;- ys + rnorm(n = n, mean = mean2, sd = sqrt(var2))\n  \n  # Equal weights\n  e1 &lt;- 0.5*y1 + 0.5*y2\n  \n  # Variance weights\n  yhat_vars  &lt;- unlist(map(list(y1, y2), function(e){var(e)}))\n  wght_vars  &lt;- (1/yhat_vars)/sum(1/yhat_vars)\n  e2 &lt;- wght_vars[1]*y1 + wght_vars[2]*y2\n  \n  # RMSE weights\n  yhat_rmses &lt;- unlist(map(list(y1, y2), function(e){sqrt((sum((ys-e)**2)/n))}))\n  wght_rmses &lt;- (1/yhat_rmses)/sum(1/yhat_rmses)\n  e3 &lt;- wght_rmses[1]*y1 + wght_rmses[2]*y2\n  \n  # Aggregate predictions and accuracy\n  data &lt;- data.frame(xs, ys, y1, y2, unif = e1, var = e2, rmse = e3)\n  plt_data &lt;- data %&gt;% \n    select(-xs) %&gt;% \n    pivot_longer(cols = c(y1, y2, unif, var, rmse)) %&gt;% \n    rename(y_pred = value) %&gt;% \n    # Calc RMSE\n    group_by(name) %&gt;%                \n    mutate(y_se = (ys - y_pred)**2) %&gt;% \n    summarise(y_rmse = sqrt(mean(y_se))) %&gt;% \n    ungroup() %&gt;% \n    mutate(mean1 = mean1,\n           mean2 = mean2,\n           var1 = var1,\n           var2 = var2)\n  \n  return(plt_data)\n}\n\n\nNext we’ll define the variables to examine in our computational experiment.\nWe can think about combining models that differ in accuracy (error mean) and precision (error variation). These differences can be are easier to think about visually. Here are the four “flavors” of model that we would like to combine to test all combinations of accuracy and precision.\n\n\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n\n\nWarning: Using the `size` aesthetic in this geom was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` in the `default_aes` field and elsewhere instead.\n\n\n\n\n\n\n\n\nSpecifically, We’ll have one model that acting as a stable reference and vary the error of the other (y2). We’ll make a version of the y2 model that is accurate (the mean error is only shifted by 0.01) and one that is inaccurate (the mean error is shifted by 50). Then we’ll see what happens when these two go from being precise (variance around 0.01) to very imprecise (variance up to 100).\nIn R this is expressed as below. When the mean of the error (mean_shift) is near zero accuracy is high. When the variance of the error (var_shift) is near zero precision is high.\n\nparams &lt;- expand.grid(\n  mean_shift = seq(0.01, 50, length.out = 2),\n  var_shift = c(seq(0.01, 0.99, length.out = 50), seq(1, 100, length.out = 90))\n)\n\nThis results in quite a few (280) combinations. of parameters Let’s look at the first and last few:\n\n\n\n\n\n\nmean_shift\nvar_shift\n\n\n\n1\n0.01\n0.01000\n\n\n2\n50.00\n0.01000\n\n\n3\n0.01\n0.03000\n\n\n278\n50.00\n98.88764\n\n\n279\n0.01\n100.00000\n\n\n280\n50.00\n100.00000\n\n\n\n\n\n\nNow we’ll generate the results. This code may look confusing at first. Here’s what it’s doing. 1. run_sim executes the steps we did above, using the parameters we specified in params to generate 100,000 observations and calculate the expected RMSE of each approach. 1. map is a way of looping over some input and putting all of the results into a list. In this case we’re looping over all the the rows in params so we will end up with a list containing a data.frame for each of the 280 parameter combinations. 1. rbind will combine two data.frames, ‘stacking’ one on top of the other. However, it can’t use a list as input so… 1. we have to use do.call. It will iteratively apply a function (rbind) to the entries in a list so that all the simulation results end up in one big data.frame.\n\nsim_data &lt;- do.call(         # 4.\n  rbind,                     # 3\n  map(seq(1, nrow(params)),  # 2.\n      function(i){           \n        run_sim(             # 1.\n          n = 10000,\n          mean1 = 0,\n          mean2 = unlist(params[i, 'mean_shift']), \n          var1 = 1,\n          var2 = unlist(params[i, 'var_shift']))\n      })\n)\n\nOnce this runs we can look at the results. Let’s consider the high accuracy y2 first, starting where y2’s variance is less than or equal to y1’s variance (1).\n\n\n\n\n\n\n\n\nWhen y2’s variance is very small (&lt; ~0.2) it outperforms all other estimates (just like the previous simulation). As it increases it crosses the line for \\(rmse^{-1}\\) weighting (rmse, orange line) and then the other averaging schemes before converging with y1 (dashed blue line). Over the same span \\(rmse^{-1}\\) converges with \\(var^{-1}\\) (var, red line), and the simple average (unif, black line).\n\n\n\n\n\n\n\n\nAs y2 continues to worsen, every prediction (except those from y1) get worse and worse. What’s interesting is that this doesn’t happen at the same rate. Because \\(rmse^{-1}\\) weighting penalizes predictions from models based on accuracy its error grows much more slowly than \\(var^{-1}\\) weighting or uniform weighting.\nTo summarize – If two models are equally good (1 on the y axis) then using any of the averaging strategies here will be better than not averaging. If one is far and away better than the other then it’s best to ignore the worse one. In practice one might find they have models that are performing in the same ballpark of accuracy. These results would suggest that in that case one gets the best results by \\(rmse^{-1}\\) weighting.\nNow let’s add in the case where one model is highly inaccurate. In this case, as precision worsens y2 (top blue line) has higher error but this is hard to see given just how much error it has to begin with. Uniform weighting follows a similar trend (but lessened by half) while \\(var^{-1}\\) improves as y2 becomes more imprecise because this decreases it’s influence on the final prediction. Of the averages \\(rmse^{-1}\\) is the best by a country mile because it accounts for the inaccuracy of y2 right from the start."
  },
  {
    "objectID": "posts/DanielKick/230607_simulating_ensembles/index.html#what-if-models-err-in-different-directions",
    "href": "posts/DanielKick/230607_simulating_ensembles/index.html#what-if-models-err-in-different-directions",
    "title": "Simulation as a Super Power",
    "section": "What if models err in different directions?",
    "text": "What if models err in different directions?\nJust for fun, let’s add one more simulation. Let’s suppose we have two models that are equally precise but err in opposite directions. We can modify the code above like so to have some combinations that are equally accurate (just in oppostie directions) and with differing accuracies.\n\nshift_array = seq(0.01, 10, length.out = 40)\nparams &lt;- expand.grid(\n  mean_shift  =    shift_array,\n  mean_shift2 = -1*shift_array\n)\n\nLet’s consider the case where errors are equal and opposite. In the previous simulation, when model variances were equal (1) the performance of all the averages converged, so we might expect that to be the case here. We can see the models getting worse and worse, but can’t see what’s happening with the averages.\n\n\n\n\n\n\n\n\nIf we zoom in, it looks like our intuition is correct (ignoring some sampling noise).\n\n\n\n\n\n\n\n\nBut we also simulated combinations where one model was off by more than the other. Let’s plot all the combinations of mean1 and mean2 but instead of showing the error of each method like we’ve done above, let’s instead just show where each method produces the best results.\n\n\n\n\n\n\n\n\nConsistent with what we’ve seen, for most of these combinations \\(rmse^{-1}\\) performs best. We can get a little fancier by color coding each fo these cells by the best expected error (y_rmse) and color coding the border with the method that produced the best expected error (excepting \\(rmse^{-1}\\) since that accounts for so much of the space).\n\n\n\n\n\n\n\n\nIt looks like there’s a sort of saddle shape off the diagonal. We’ll re-plot these data in 3d so we can usethe z axis for y_RMSE and color code each point as above.\n\n\n\n\n\n\nThere we go. Just a little bit of scripting and plotting will let one answer a whole lot of questions about statistics."
  },
  {
    "objectID": "posts/DanielKick/230607_simulating_ensembles/index.html#footnotes",
    "href": "posts/DanielKick/230607_simulating_ensembles/index.html#footnotes",
    "title": "Simulation as a Super Power",
    "section": "Footnotes",
    "text": "Footnotes\n\nI added a fair bit more for the sake of this post↩︎\nFor simplicity we’re not using testing and training sets. In this simulation that shouldn’t be an issue, but one might consider cases where this could matter. For instance if one model was wildly over fit then its RMSE would not be predictive of its RMSE on newly collected data↩︎"
  },
  {
    "objectID": "posts/DanielKick/220928_python_trivia_missing/index.html",
    "href": "posts/DanielKick/220928_python_trivia_missing/index.html",
    "title": "Trivia: In Python Missing Isn’t Equal to Itself",
    "section": "",
    "text": "Python quirk I just learned and think is worth sharing. A missing valued doesn’t equal itself.\nHere’s the context: I’m making a list of values from a column that could not be converted to a date. Missing values can’t be converted so they end up in the list (e.g. [nan, '7/5/21 for pass 2']. So how do we discard this empty value? We use a list comprehension to see if the value is equal to itself ( [val for val in my_list if val == val] ) and will get a nan free list."
  },
  {
    "objectID": "posts/DanielKick/230912_vignettes_for_tacit_knowledge/index.html",
    "href": "posts/DanielKick/230912_vignettes_for_tacit_knowledge/index.html",
    "title": "Capturing Tacit Knowledge Through Blogging",
    "section": "",
    "text": "One of my goals with mentoring is to help others avoid places I got stuck (or get through them more easily) when I was learning. Part of this is writing guides, documentation, SOPs, etc. that I wish I had, but there’s some knowledge that doesn’t fit into a nice long form documents.\nTacit knowledge (e.g. how to approach different problems) or helpful little tricks aren’t well suited to that sort of format. Posts in this series are designed to collect thoughts in this vein to hopefully help out a fellow computational traveler starting their journey.\nTo that end these posts will be a mix of tricks, advice, retrospectives, and maybe a few guides that don’t fit in the protocols/ folder."
  },
  {
    "objectID": "posts/DanielKick/230912_vignettes_for_tacit_knowledge/index.html#advice-à-la-carte",
    "href": "posts/DanielKick/230912_vignettes_for_tacit_knowledge/index.html#advice-à-la-carte",
    "title": "Capturing Tacit Knowledge Through Blogging",
    "section": "",
    "text": "One of my goals with mentoring is to help others avoid places I got stuck (or get through them more easily) when I was learning. Part of this is writing guides, documentation, SOPs, etc. that I wish I had, but there’s some knowledge that doesn’t fit into a nice long form documents.\nTacit knowledge (e.g. how to approach different problems) or helpful little tricks aren’t well suited to that sort of format. Posts in this series are designed to collect thoughts in this vein to hopefully help out a fellow computational traveler starting their journey.\nTo that end these posts will be a mix of tricks, advice, retrospectives, and maybe a few guides that don’t fit in the protocols/ folder."
  },
  {
    "objectID": "posts/DanielKick/210621_python_data_readability/index.html",
    "href": "posts/DanielKick/210621_python_data_readability/index.html",
    "title": "Tips: More Readable Data with pretty-print",
    "section": "",
    "text": "Here’s a tool that some may find useful when working with data that’s not yet in a [DataFrame]. It lets one “pretty-print” an object making any text that would wrap easier to read.\n# [In]\nprint(results_dictionary)\nprint(\"\\n --------------------------------------------- \\n\")\nimport pprint\npprint.PrettyPrinter(indent=4).pprint(results_dictionary)\n# [Out]\n{'active': True, 'additionalInfo:programDbId': '343', 'additionalInfo:programName': 'UC Davis', 'commonCropName': 'Cassava', 'contacts': None, 'culturalPractices': None, 'dataLinks': [], \n# ...\n'trialDbId': '343', 'trialName': 'UC Davis'}\n--------------------------------------------- \n{   'active': True,\n    'additionalInfo:programDbId': '343',    'additionalInfo:programName': 'UC Davis',    'commonCropName': 'Cassava',    'contacts': None,    'culturalPractices': None,    'dataLinks': [],    # ...    'trialDbId': '343',    'trialName': 'UC Davis'}"
  },
  {
    "objectID": "posts/DanielKick/210615_python_graph_gallery/index.html",
    "href": "posts/DanielKick/210615_python_graph_gallery/index.html",
    "title": "Tips: Find the Graph you want in using a Graph Gallery",
    "section": "",
    "text": "This or similar sites can be helpful for looking up the right code/library for a plot. You can also find library specific ones. (matplotlib, plotly)\nOne of R’s main plotting libraries, ggplot2, describes plots by layering one component on top of another (e.g. starting with x and y variables, adding points, adding error bars, adding aesthetic adjustments). If that sort of approach appeals to you there is a python version of this library called plotnine (github, example use)."
  },
  {
    "objectID": "posts/DanielKick/231013_premature_optimiztion_worse_is_better/index.html",
    "href": "posts/DanielKick/231013_premature_optimiztion_worse_is_better/index.html",
    "title": "Worse is better and not doing things “right”",
    "section": "",
    "text": "“Worse is better” is an idea I get a lot of mileage out of. Here’s the crux of it:\nI find this is useful descriptively1 but also prescriptively as a way to spend less time doing work that doesn’t need to be done.\nIn brief the idea is that once you have something that works it’s often not worth altering it to make it faster, more efficient, or more elegant … at least initially. Optimization is important (example but what I’m talking about here premature optimization. Avoiding the urge to improve things that aren’t the priority can be difficult, especially when you conceptually know what you would change."
  },
  {
    "objectID": "posts/DanielKick/231013_premature_optimiztion_worse_is_better/index.html#simplified-example",
    "href": "posts/DanielKick/231013_premature_optimiztion_worse_is_better/index.html#simplified-example",
    "title": "Worse is better and not doing things “right”",
    "section": "Simplified Example",
    "text": "Simplified Example\nHere’s an example: I’m building a network that ‘compresses’ information. The key idea is that there’s a function, f(), takes in some number of values and outputs fewer values. We can use this function over and over again to compress the values more and more. Once they’re ‘compressed’ we can do the reverse procedure and get more values until we’re back at the starting number.\nThere’s a catch however, and that’s that the function can only output an integer number of values even if the number should be a fraction. It’s like this division function. If the numerator argument is the number of input values and it will return numerator/3 values.\n\ndiv_it &lt;- function(numerator, divisor = 3){\n  res = numerator/divisor\n  res = round(res)\n  return(res)\n}\n\ndiv_it(100)\n\n[1] 33\n\n\nBecause it can only return whole numbers, we can’t reverse this procedure and always get back the same number – sometimes we have to add or subtract a little bit.\n\ninv_div_it &lt;- function(numerator, divisor = 3){\n  return(numerator*divisor)\n}\n\ninv_div_it(33)\n\n[1] 99\n\ninv_div_it(33)+1\n\n[1] 100\n\n\nIf we want to really compress the input (f(X) |&gt; f(X) |&gt; f(X) |&gt; f(X) or f(f(f(f(X))))) then the number of values at each level would be:\n\nvals &lt;- c(100)\nfor(i in 1:4){\n  i_val &lt;- vals[length(vals)]\n  vals[length(vals)+1] &lt;- div_it(i_val) \n}\nvals\n\n[1] 100  33  11   4   1\n\n\nIdeally running the inverse procedure multiple times on the last output above (just one value) would output produce:\n\nvals_reverse &lt;- vals[length(vals):1]\nvals_reverse\n\n[1]   1   4  11  33 100\n\n\nBut using the inverse function defined above (inv_div_it()) we get:\n\nrecover_vals &lt;- c(1)\nfor(i in 1:4){\n  i_val &lt;- recover_vals[length(recover_vals)]\n  recover_vals[length(recover_vals)+1] &lt;- inv_div_it(i_val) \n}\nrecover_vals\n\n[1]  1  3  9 27 81\n\n\nTo get back to 100 values we need to add a new value (imagine appending a 1 to an array) sometimes, and drop a value others, or make no change to output other times.\n\nadd_vals &lt;- c(1, -1, 0, 1)\n\nrecover_vals &lt;- c(1)\nfor(i in 1:4){\n  i_val &lt;- recover_vals[length(recover_vals)]\n  print(add_vals[i])\n  recover_vals[length(recover_vals)+1] &lt;- inv_div_it(i_val) + add_vals[i]\n}\n\n[1] 1\n[1] -1\n[1] 0\n[1] 1\n\nrecover_vals\n\n[1]   1   4  11  33 100\n\n\nWe could keep track of the remainder each time f() is called and use that to figure out when to add or subtract 1. That would be the elegant and efficient solution. We know the desired output (100 values) and the number of times f() was called (4) so we could also try changing the numbers in add_vals until we have four numbers that. This solution would be inelegant but still effective.\nIf a piece of code only needs to be a few times then the cost of the time you’d spend optimizing it will probably be worth more than than cost of the time the computer spends running it (see also).\nIf the sloppy way to express what you want is good enough then don’t worry about it. Good enough now is often better than perfect later."
  },
  {
    "objectID": "posts/DanielKick/231013_premature_optimiztion_worse_is_better/index.html#example-in-context-python",
    "href": "posts/DanielKick/231013_premature_optimiztion_worse_is_better/index.html#example-in-context-python",
    "title": "Worse is better and not doing things “right”",
    "section": "Example in Context (python)",
    "text": "Example in Context (python)\nThe motivating problem behind this write up is that ‘compressing’ weather data (17 measurements for 365 days) into fewer values. I’m using a variation autoencoder with convolution layers which you can imagine as passing a sliding window over a 17x365 grid and summarizing each windowed chunk to get fewer values.\nTo check if the compression is effective, we have to compress 17x365 values down to something smaller (e.g. 17x23), and inflate them back to 17x365 so we can compare the input weather to the output weather. If we can get back the same 17x365 values (or something pretty close) then the comprssion is effective..\nFrom the input data’s length (days) you can calculate what a convolutional layer’s output length will be like so:\ndef L_out_conv1d(\n    L_in = 365, \n    kernel_size=3, stride = 2, padding=1, dilation = 1\n): return ((L_in +2*padding-dilation*(kernel_size-1)-1)/stride)+1\n\nL_out_conv1d(L_in = 365) # 183.0\nAnd the same for reversing the operation (with a transposed convolution).\ndef L_out_convT1d(\n    L_in = 183, \n    kernel_size=3, stride = 2, padding=1, output_padding=0, dilation = 1\n): return (L_in - 1)*stride-2*padding+dilation*(kernel_size-1)+output_padding+1\n\nL_out_convT1d(L_in = 183) # 365.0\nThe trouble is that if I stack convolution layers the output length can become a fraction, which is forced to an integer, and prevents the reverse operation from producing the right number. When I use 4 layers the length should be [365, 183.0, 92.0, 46.5, 23.75] which as integers is [365, 183, 92, 46, 23]. Reversing the operation produces [23, 45, 89, 177, 353].\nWe can get back to 365 days by increasing the output’s length in some of the transposed convolution layers by adding a non-zero output_padding. I don’t know how many layers will be best, so I can’t hard code these values. I could use the functions above to calculate what when the output_padding should be 0 and when it shouldn’t (the elegant solution), but that’s not what I did.\nInstead I made a simple disposable neural network just to check if I had the output_paddings right by tracking the lengths of the tensor after each layer.\n# input data. One observation, 17 measurements, 365 days of measurements. \n# It's all 0s because all I care about right now is the dimensions of the data.\nxin = torch.zeros((1, 17, 365))\n\n# Proposed output_padding for each layer in the decoder network\nlayer_output_padding = [0, 0, 0, 0, 0, 0, 0, 0]\n\n# encoder network\nne = nn.ModuleList([\n    nn.Sequential(nn.Conv1d(\n    17, out_channels=17, kernel_size= 3, stride= 2, padding  = 1), nn.BatchNorm1d(\n    17), nn.LeakyReLU())\n    for i in range(len(layer_output_padding))\n])\n\n# Decoder network\nnd = nn.ModuleList([\n    nn.Sequential(nn.ConvTranspose1d(\n    17, 17, \n    kernel_size=3, stride = 2, padding=1, output_padding=layer_output_padding[i]), nn.BatchNorm1d(\n    17), nn.LeakyReLU())\n    for i in range(len(layer_output_padding))\n])\nThen I can run this network …\n# list to store lengths\ntensor_Ls = []\n\n# add the input data's length (days)\ntensor_Ls += [list(xin.shape)[-1]] \n\n# encode data\nfor mod in ne:\n    xin = mod(xin)\n    tensor_Ls += [list(xin.shape)[-1]]\n\n# add the encoded data's \ntensor_Ls += [str(tensor_Ls[-1])]\n\n# decode data\nfor mod in nd:\n    xin = mod(xin)\n    tensor_Ls += [list(xin.shape)[-1]]\n… and look at the first and last value of the list of lengths (tensor_Ls) to see if the proposed output paddings will work.\ntensor_Ls[0] == tensor_Ls[-1]\n# False\ntensor_Ls\n# [365, 183, 92, 46, 23, 12, 6, 3, 2, '2', 3, 5, 9, 17, 33, 65, 129, 257]\nNext I need a way to systematically produce different paddings. For a decoder of four layers I would test paddings [0, 0, 0, 0], [1, 0, 0, 0], ... [1, 1, 1, 1] stopping at the first list that works. So I’ll write a function to increment [0, 0, 0, 0] to [1, 0, 0, 0].\ndef increment_list(\n    in_list = [0, 0, 0, 0],\n    min_value = 0,\n    max_value = 1):\n    # Check that all entries are within min/max\n    if False in [True if e &lt;= max_value else False for e in in_list]:\n        print('Value(s) above maximum!')\n    elif False in [True if e &gt;= min_value else False for e in in_list]:\n        print('Value(s) below minimum!')\n    elif [e for e in in_list if e != max_value] == []:\n        print('List at maximum value!')\n    else:    \n        # start cursor at first non-max value\n        for i in range(len(in_list)):\n            if in_list[i] &lt; max_value:\n                in_list[i] += 1\n                break\n            else:\n                in_list[i] = min_value\n    return(in_list)\n\nincrement_list()\n# [1, 0, 0, 0]\nThen we can loop through possible paddings until we find one that works or have tried all of them.\n# Proposed output_padding for each layer in the decoder network\nlayer_output_padding = [0, 0, 0, 0, 0, 0, 0, 0]\n\nwhile True:\n    # save a backup of the current padding\n    old_layer_output_padding = layer_output_padding.copy()\n    \n    \n    # ... define and run network here ...\n    \n    \n    # If it did work we're done\n    if True == (tensor_Ls[0] == tensor_Ls[-1]):\n        print('done!')\n        \n    # If the padding _didn't_ work change it\n    else:\n        layer_output_padding = increment_list(\n            in_list = layer_output_padding,\n            min_value = 0,\n            max_value = 1)\n    \n    # If the proposed new padding is the same as the backup, then we have tried all the possible paddings and will stop. \n    if layer_output_padding == old_layer_output_padding: \n        break\nAll together\nHere’s the full loop and its output:\n\n# Proposed output_padding for each layer in the decoder network\nlayer_output_padding = [0, 0, 0, 0, 0, 0, 0, 0]\n\nwhile True:\n    # save a backup of the current padding\n    old_layer_output_padding = layer_output_padding.copy()\n    \n    # input data. One observation, 17 measurements, 365 days of measurements. \n    # It's all 0s because all I care about right now is the dimensions of the data.\n    xin = torch.zeros((1, 17, 365))\n\n    # encoder network\n    ne = nn.ModuleList([\n        nn.Sequential(nn.Conv1d(\n        17, out_channels=17, kernel_size= 3, stride= 2, padding  = 1), nn.BatchNorm1d(\n        17), nn.LeakyReLU())\n        for i in range(len(layer_output_padding))\n    ])\n\n    # Decoder network\n    nd = nn.ModuleList([\n        nn.Sequential(nn.ConvTranspose1d(\n        17, 17, \n        kernel_size=3, stride = 2, padding=1, output_padding=layer_output_padding[i]), nn.BatchNorm1d(\n        17), nn.LeakyReLU())\n        for i in range(len(layer_output_padding))\n    ])\n    \n    # list to store lengths\n    tensor_Ls = []\n\n    # add the input data's length (days)\n    tensor_Ls += [list(xin.shape)[-1]] \n\n    # encode data\n    for mod in ne:\n        xin = mod(xin)\n        tensor_Ls += [list(xin.shape)[-1]]\n\n    # add the encoded data's \n    tensor_Ls += [str(tensor_Ls[-1])]\n\n    # decode data\n    for mod in nd:\n        xin = mod(xin)\n        tensor_Ls += [list(xin.shape)[-1]]    \n    \n    # If it did work we're done\n    if True == (tensor_Ls[0] == tensor_Ls[-1]):\n        print('done!')\n        \n    # If the padding _didn't_ work change it\n    else:\n        layer_output_padding = increment_list(\n            in_list = layer_output_padding,\n            min_value = 0,\n            max_value = 1)\n    \n    # If the proposed new padding is the same as the backup, then we have tried all the possible paddings and will stop. \n    if layer_output_padding == old_layer_output_padding: \n        break\n\n# done!\n\nlayer_output_padding  \n# [0, 1, 1, 0, 1, 1, 0, 0]\n\ntensor_Ls\n# [365, 183, 92, 46, 23, 12, 6, 3, 2, '2', 3, 6, 12, 23, 46, 92, 183, 365]\nThis may not be as not as elegant or as efficient as it could be, but it doesn’t matter. It only takes about 200ms so it’s not worth improving unless."
  },
  {
    "objectID": "posts/DanielKick/231013_premature_optimiztion_worse_is_better/index.html#footnotes",
    "href": "posts/DanielKick/231013_premature_optimiztion_worse_is_better/index.html#footnotes",
    "title": "Worse is better and not doing things “right”",
    "section": "Footnotes",
    "text": "Footnotes\n\ne.g. If scientific manuscripts with embedded code are valuable for reproducibility, why haven’t they become the default? There’s a lot of energy needed to switch and all of your collaborators already know word. 🤷🏼‍♂ ↩︎"
  },
  {
    "objectID": "posts/DanielKick/220523_r_comments_in_tables/index.html",
    "href": "posts/DanielKick/220523_r_comments_in_tables/index.html",
    "title": "Trivia: R can have Comments in Tables",
    "section": "",
    "text": "R allows for comments to exist in tables. If there’s a # in the table you’re reading (e.g. as a part of a column name like chromosome#) then it can cause an unequal number of values between rows (everything on that line following it is ignored). The solution is to specify the comment character explicitly to be used (it can be ’’ to have no comment characters). Here’s an example:\necho \"a, b, c#, d\" &gt; test_table.txt\n&gt; Rscript -e \"read.table('test_table.txt')\"\n#   V1 V2 V3\n# 1 a, b,  c\n&gt; Rscript -e \"read.table('test_table.txt', comment.char = '')\" # with no comment character, all entries will be read\n#   V1 V2  V3 V4\n# 1 a, b, c#,  d"
  },
  {
    "objectID": "posts/manuscript-kick-and-schulz-2018/index.html",
    "href": "posts/manuscript-kick-and-schulz-2018/index.html",
    "title": "Motor Systems: Variability in neural networks",
    "section": "",
    "text": "https://elifesciences.org/articles/34153"
  },
  {
    "objectID": "curriculum-vitae.html",
    "href": "curriculum-vitae.html",
    "title": "Curriculum Vitae",
    "section": "",
    "text": "If no file appears, please follow this link."
  },
  {
    "objectID": "hype-doc-2023.html",
    "href": "hype-doc-2023.html",
    "title": "Hype-Doc-2023",
    "section": "",
    "text": "Problem: I have the feeling that I’m not growing technically and not sure how to ensure I 1) keep growing in a direction with utility 2) align that growth with publishable projects.\nPlaces for growth:\n\n\nBasic manipulation and understanding of genomes + gene networks\n\nFile manipulation, downsampling, gene identification, linkage disequalibrium\nGene pathways, GO terms\n\n\n\nModeling:\n\n\nGWAS\n\nCan I perform and interpret GWAS?\nCan I explain the basic theory behind it?\n\n\n\nMLMs\n\nHow do they work under the hood? How are random effects encoded? Can I accurately explain the differences between fixed and random effects?\nCan I understand the matrix notation? Could I puzzle out code from an equation if my life depended on it?\nCan I explain correlation structures and how it factors into model fitting?\nCan I extract and interpret breeding values from BLUPs and BLUEs?\nCan I explain how spatial data can be included into a model?\n\n\n\nPhysiological growth models\n\nDo I understand the basic theory?\nDo I know how to get started using them if I needed to?\n\n\n\nNeural nets\n\nCan I satisfactorally explain the basics of a dnn?\nDo I know when to use more complicated architectures/techniques (BNNs, Auto encoders, variational AEs, RNNs, Transformers, etc)\nWould I be able to implement a more complicated model?\n\nHow much inference can I get from the predictions and inputs?\n\nPDPs, LWRP, Salience, SHAP, LIME, etc.\n\n\n\n\n\nCausality\n\nCan I explain (at a high level) differerent ways to approach causality? (DAGs, residual discontinuity, others?)\n\n\n\nBayesian Statistics\n\nCan I explain the advantages/disadvantages of using bayesian methods vs (RE)ML\nCan I implement models (LM, MLM, BayesC) in STAN, PyMC3, or another related program?\n\n\n\n\n\nData extraction\n\nUAV data\nImage analysis\n\n\n\nSelection\n\nCan I explain the breeders equation and common breeding strategies?\nCan I explain where modeling fits in and adds value\n\n\n\nGoals for this year\nReflections\n\nWhat work do I feel most proud of?\nAre there themes in these projects I should be thinking about?\nWhat do I wish I was doing more/less of?\nWhich of my projects had the effect I wanted, and which didn’t\nWhat could have gone better with a project and what might I want to do differently?\nProjects\n(contributions, components, instights) (impact)\nCollaboration & mentorship\nDesign & documentation\nCompany building\n(things that help the company overall, not just your team/project) Recruiting, improving important processes\nWhat you learned\nOutside of work\nBlog postes, open source, talks/ panels"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "I am a PhD Biologist working as a research geneticist. Currently, my research focuses on using deep learning to predict maize yield from genetic, environmental, and management data using deep learning, machine learning, and statistical modeling. Previously, I focused on compensation of neural circuits to aberrant activity."
  }
]