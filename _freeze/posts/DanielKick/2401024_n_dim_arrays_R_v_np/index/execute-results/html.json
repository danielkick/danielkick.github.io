{
  "hash": "cbc6d498375992c791e1bd354aefe3ad",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Sharing n-dimensional data between Python and R\"\nsubtitle: \"\"\nauthor: \"Daniel Kick\"\ndate: \"2024-10-24\"\nimage: \"https://upload.wikimedia.org/wikipedia/commons/7/7d/Laminated_cube_in_a_magnetic_field.png\"\ncategories: \n  - python\n  - r\n  - numpy\n  - arrays\n  - tips\n  - parquet\nfreeze: true\n---\n\n\n\n## Motivating Problem\n\nStoring multidimensional data is a pain. In R or python you can save the n-dimensional array to disk, but not in a way that is easily accessible by the other. Admittedly, this is a rare issue to want to solve (It's taken 3 years of deep learning for it to come up) but it's worth discussing regardless as it illustrates a stumbling block when working between these languages. Think of it as the advanced version of trying to get the 0th entry in a R vector.\n\nZooming out, if we have a 3d array of data (say observations by nucleotides by SNPs) we have a few options on how to save it.\n\n1.  We could save it in a format designed for n-dim arrays (e.g. numpy's `.npz` format). I'm not aware of any options that would allow for reading into both R and python (there certainly could be some) so we'll ignore this option.\n\n2.  We could reduce this to a set of 2d arrays and save the lot. Then we can use any format for tabular data -- text files, sqlite databases, parquet files -- all would be an option. The downside is we'd be working with (potentially) many files. This isn't a deal breaker[^1] but it would be nice to avoid.\n\n3.  We could store the data and dimensions *separately.* We would end up with only two files each with a 1d array representing the values and dimensions. We could even put the dimensions in the name of the file if we wanted to and lets us use all the file types in option 2. Reshaping the data sounds nicer than reconstituting it so let's go with that.\n\n[^1]: Once I split a file with genomes into several thousand files just to minimize what had to be read in.\n\nI'm a fan of parquet files for storing large amounts of data, especially when they need to be accessible by multiple programming languages. So the plan will be to turn the n-dim array into a 1-dim array and store the original dimension separately. On the other end we'll reshape this 1-dim array back into the right shape. Easy, right?\n\n## The Curse of Dimensionality (but not that one)\n\nIt's easiest to see the problem with an example. Suppose we want to \"remake\" 3d data of shape (2, 3, 4). We're starting with an array of values (`vals`) which are the integers 0-23. We can reshape this array using `.reshape` and then look at at the 0th plane of the data.\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# original python\nimport numpy as np\narr_shape = (2,3,4)\nvals = np.arange(np.prod(arr_shape))\n\nx = np.array(vals).reshape(arr_shape)\nx[0, :, :]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11]])\n```\n\n\n:::\n:::\n\n\n\nWhen we repeat this in R (selecting the 1st plane because R is not 0 indexed) we *don't* get the same values.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# original R\narr_shape <- c(2,3,4)\nvals <- seq(0, prod(arr_shape)-1 )\n\nx <- array(vals, dim = arr_shape)\nx[1, , ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]    0    6   12   18\n[2,]    2    8   14   20\n[3,]    4   10   16   22\n```\n\n\n:::\n:::\n\n\n\n## What's going on and how do we fix it?\n\nIt's easiest to see what's happening by looking for the slice that begins with 0.\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nx[0, 0, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\narray([0, 1, 2, 3])\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nx[, 1, 1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0 1\n```\n\n\n:::\n:::\n\n\n\nThese values are in the last dimension in python but the first in R! In effect, numpy and R 'fill' values from the opposite directions.\n\nSo how do we fix this? We have to change the shape of the array so that it fills properly and then \"rotate\" the dimensions until we have the right shape. We'll do this by\n\n1.  Reversing the desired dimensions\n\n2.  Filling the values into the array\n\n3.  Swapping the axes (swapping the first and last, second and penulitmate, etc. )\n\nFinally, here's how this would be done for either language:\n\n## Option 1: Remaking a Numpy array in R\n\nHere's the python we want to mimic:\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# original python\nimport numpy as np\narr_shape = (2,3,4)\nvals = np.arange(np.prod(arr_shape))\n\nx = np.array(vals).reshape(arr_shape)\nx[0, :, :]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11]])\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\narr_shape <- c(2,3,4)\nvals <- seq(0, prod(arr_shape)-1 )\n\nx <- array(vals, dim = rev(arr_shape)) # reverse the dims\nx <- aperm(x, rev(seq_along(arr_shape)))    # transpose by permuting dims\nx[1, , ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]    0    1    2    3\n[2,]    4    5    6    7\n[3,]    8    9   10   11\n```\n\n\n:::\n:::\n\n\n\n## Option 2: Remaking a R array in Numpy\n\nHere's the R we want to mimic:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# original R\narr_shape <- c(2,3,4)\nvals <- seq(0, prod(arr_shape)-1 )\n\nx <- array(vals, dim = arr_shape)\nx[1, , ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]    0    6   12   18\n[2,]    2    8   14   20\n[3,]    4   10   16   22\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nimport numpy as np\narr_shape = (2,3,4)\nvals = np.arange(np.prod(arr_shape))\n\narr_shape = list(arr_shape)\narr_shape.reverse() # now is [4, 3, 2]\nx = np.array(vals).reshape(arr_shape)\n# we only want to iterate over the first half of the list.\n# Iterating over all of it will swap all axes and then swap them back\n# Coercing 1/2 the length to an int will round down values in the case of odd dims\nfor i in range( int(len(arr_shape) / 2) ): \n  j = (len(arr_shape)-1)-i\n  x = x.swapaxes(i, j)\nx[0, :, :]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\narray([[ 0,  6, 12, 18],\n       [ 2,  8, 14, 20],\n       [ 4, 10, 16, 22]])\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}